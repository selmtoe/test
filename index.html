<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1a1a2e">
<link rel="manifest" id="manifest-link">
<title>Tetris Simulator</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
<style>
    :root {
        --bg-color: #1a1a2e; --primary-color: #4b4b7c; --primary-hover-color: #6a6aff;
        --font-color: #e0e0e0; --border-color: #4b4b7c; --canvas-bg-color: #0f0f18;
        --font-display: 'Orbitron', sans-serif; --font-ui: 'Noto Sans JP', sans-serif;
    }
    html, body {
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        -webkit-tap-highlight-color: transparent;
    }
    body {
        background-color: var(--bg-color);
        color: var(--font-color);
        font-family: var(--font-ui);
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .main-container {
        text-align: center;
        transform-origin: center center;
    }
    #editor-container {
        display: flex; flex-direction: column; gap: 15px; background-color: rgba(15, 15, 24, 0.8);
        padding: 20px; border-radius: 10px; border: 2px solid var(--border-color);
        width: 100%; max-width: 1200px; margin-bottom: 20px;
    }
    #game-container { display: none; }
    canvas {
        background-color: var(--canvas-bg-color); border-radius: 8px;
        border: 2px solid var(--border-color);
    }
    h2 {
        font-family: var(--font-display); color: var(--primary-hover-color); margin: 0 0 10px 0;
        border-bottom: 2px solid var(--primary-color); padding-bottom: 5px; text-align: center;
    }
    .button, button, label.button {
        background-color: var(--primary-color); color: var(--font-color); border: none;
        padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 14px;
        font-family: var(--font-display); transition: background-color 0.2s;
        text-align: center; display: inline-block;
    }
    .button:hover, button:hover, label.button:hover { background-color: var(--primary-hover-color); }
    input[type="file"] { display: none; }

    .edit-section { background-color: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; }
    .top-controls { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }
    .mode-selection { display: flex; gap: 10px; align-items: center;}
    .mode-selection .button.active { background-color: var(--primary-hover-color); box-shadow: 0 0 10px var(--primary-hover-color);
    }
#p1-touch-mode-selection .button.active {
    background-color: var(--primary-hover-color);
    box-shadow: 0 0 10px var(--primary-hover-color);
}

    .player-editors { display: flex; justify-content: space-around; gap: 20px; flex-wrap: nowrap; margin-top: 15px;
    }
    .editor-column { flex: 1; min-width: 320px; display: flex; flex-direction: column; gap: 15px; }

    .mino-icons, .color-palette { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
    .mino-icon, .color-swatch {
        width: 40px; height: 40px; border-radius: 4px; cursor: pointer;
        border: 2px solid transparent; transition: all 0.2s; box-sizing: border-box;
    }
    .mino-icon:hover, .color-swatch:hover { transform: scale(1.1); }
    .color-swatch.active { border-color: #fff; box-shadow: 0 0 8px #fff; }

    .next-queue-display {
        background-color: rgba(0,0,0,0.3); padding: 8px; border-radius: 5px; min-height: 38px;
        display: flex; gap: 5px; flex-wrap: wrap; border: 1px solid var(--primary-color);
    }
    .next-queue-display .mino-icon { cursor: default; }
    .editor-column .button-group { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }

    .field-editor canvas { margin-bottom: 10px; cursor: crosshair; touch-action: none; }
    .field-controls { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;}

    #startGameBtn { font-size: 24px; padding: 12px 25px; background-color: #00a000; }
    #startGameBtn:hover { background-color: #00c000; }

    #scan-instructions {
        position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8); color: white; padding: 10px 20px;
        border-radius: 10px; font-size: 18px; z-index: 100;
    }
    
#settings-modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.75);
        display: none; justify-content: center; align-items: center; z-index: 200;
    }
.modal-content {
    background-color: var(--bg-color);
    padding: 25px;
    border-radius: 10px;
    border: 2px solid var(--primary-color);
    width: 90%;
    max-width: 500px;
    font-family: var(--font-ui);
    max-height: 95vh;
    overflow-y: auto;
    box-sizing: border-box;
}


    .modal-content h2, .modal-content h3 { font-size: 24px; }
    .modal-content h3 { font-size: 20px; margin-top: 25px; border-top: 1px solid var(--primary-color); padding-top: 15px; }
#settings-list, .key-config-list-container { display: flex; flex-direction: column; gap: 12px; margin: 20px 0; }
    .key-config-item, .setting-item { display: flex; justify-content: space-between; align-items: center; padding: 5px; border-radius: 4px; }
    .key-config-item:nth-child(odd), .setting-item:nth-child(odd) { background-color: rgba(255,255,255,0.05); }
    .key-config-item span, .setting-item span, .setting-item label { font-size: 16px; color: var(--font-color); }
    .key-config-item button, .setting-item input { min-width: 150px; text-align: center; }
    .setting-item input[type="number"] { background-color: var(--primary-color); color: var(--font-color); border: 1px solid var(--border-color); padding: 5px; border-radius: 4px; font-family: var(--font-display); }
    .setting-item input[type="checkbox"] { width: 20px; height: 20px; min-width: 20px; }
    .setting-item label { display: flex; align-items: center; gap: 10px; }
    .modal-controls { text-align: center; margin-top: 15px; }

    #share-modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.75);
        display: none; justify-content: center; align-items: center; z-index: 200;
    }
    .share-section h3 {
        font-family: var(--font-display);
        color: var(--primary-hover-color);
        margin-top: 0;
        margin-bottom: 10px;
        border-bottom: 1px solid var(--primary-color);
        padding-bottom: 5px;
    }
    .share-item {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }
    #share-modal .modal-content input, #share-modal .modal-content textarea {
        background-color: var(--primary-color);
        color: var(--font-color);
        border: 1px solid var(--border-color);
        padding: 8px;
        border-radius: 4px;
        font-family: var(--font-ui);
    }
    
   
    #virtual-controller-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 150;
        display: none;
    }
    #virtualControllerCanvas {
        display: block;
        width: 100%;
        height: 100%;
        background-color: transparent;
        border: none;
    }
    #vc-edit-controls {
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 151;
        background: rgba(50, 50, 50, 0.9);
        padding: 10px 20px;
        border-radius: 8px;
        display: flex;
        gap: 15px;
        align-items: center;
    }

.modal-tabs {
    display: flex;
    border-bottom: 2px solid var(--primary-color);
    margin-bottom: 10px;
}
.tab-button {
    flex: 1;
    padding: 10px 15px;
    cursor: pointer;
    background-color: transparent;
    border: none;
    color: var(--font-color);
    font-family: var(--font-display);
    font-size: 16px;
    border-bottom: 3px solid transparent;
    transition: background-color 0.2s, border-color 0.2s;
}
.tab-button:hover {
    background-color: rgba(255, 255, 255, 0.1);
}
.tab-button.active {
    color: var(--primary-hover-color);
    border-bottom: 3px solid var(--primary-hover-color);
}
.tab-content {
    display: none;
}
.tab-content.active {
    display: block;
    animation: fadeIn 0.3s ease-in-out;
}
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

</style>
</head>
<body>

<div class="main-container">
    <div id="editor-container">
        <div class="edit-section top-controls">
<div class="mode-selection">
    <h2>MODE</h2>
    <div class="button active" id="mode-1p">1P</div>
    <div class="button" id="mode-2p">2P</div>
    <button id="settingsBtn" class="button" style="margin-left: 15px;">設定</button>
     <button id="shareBtn" class="button" style="margin-left: 5px;">共有</button>
     <button id="ruleBtn" class="button" style="margin-left: 5px;">ルール</button>
</div>
            <button id="startGameBtn" class="button">START GAME</button>
        </div>

<div class="player-editors">
            <div class="editor-column" id="p1-editor-col">
                <div class="edit-section next-editor">
                    <h2>PLAYER 1 - NEXT</h2>
                    <div class="mino-icons" id="p1-next-icons"></div>
                    <div class="next-queue-display" id="p1-next-queue"></div>
                    <div class="button-group">
                        <button class="button" id="p1-next-delete-left">Delete</button>
                        <button class="button" id="p1-next-clear">Clear</button>
                    </div>
                </div>
                <div class="edit-section field-editor">
                    <h2>PLAYER 1 - FIELD</h2>
                    <div class="color-palette" id="p1-palette"></div>

<canvas id="field-editor-canvas-p1"></canvas>
                    <div class="field-controls">
                        <button class="button" id="p1-field-shift-up">↑ Up</button>
                        <button class="button" id="p1-field-shift-down">↓ Down</button>
                        <button class="button" id="p1-field-clear">Clear</button>
                        <label for="imageLoader-p1" class="button">Load Img</label>
                        <input type="file" id="imageLoader-p1" data-player="p1" accept="image/*">
                        <label for="pptLoader-p1" class="button">Load PPT</label>
                        <input type="file" id="pptLoader-p1" data-player="p1" accept="image/*">
                    </div>
<div class="key-config-controls" style="margin-top: 15px; text-align: center; display: flex; justify-content: center; align-items: center; gap: 10px;">
                        <label class="setting-item" style="padding:0; margin:0;">
                            <input type="checkbox" id="p1-ai-toggle">
                            <span>AI</span>
                        </label>
                        <button class="button" id="p1-key-config-btn">操作設定</button>
                    </div>
                </div>
            </div>
<div class="editor-column" id="p2-editor-col" style="display: none;">
                <div class="edit-section next-editor">
                    <h2>PLAYER 2 - NEXT</h2>
                    <div class="mino-icons" id="p2-next-icons"></div>
                    <div class="next-queue-display" id="p2-next-queue"></div>
                    <div class="button-group">
                        <button class="button" id="p2-next-delete-left">Delete</button>
                        <button class="button" id="p2-next-clear">Clear</button>
                    </div>
                </div>
                <div class="edit-section field-editor">
                    <h2>PLAYER 2 - FIELD</h2>
                    <div class="color-palette" id="p2-palette"></div>

<canvas id="field-editor-canvas-p2"></canvas>
                    <div class="field-controls">
                        <button class="button" id="p2-field-shift-up">↑ Up</button>
                        <button class="button" id="p2-field-shift-down">↓ Down</button>
                        <button class="button" id="p2-field-clear">Clear</button>
                        <label for="imageLoader-p2" class="button">Load Img</label>
                        <input type="file" id="imageLoader-p2" data-player="p2" accept="image/*">
                        <label for="pptLoader-p2" class="button">Load PPT</label>
                        <input type="file" id="pptLoader-p2" data-player="p2" accept="image/*">
                    </div>
<div class="key-config-controls" style="margin-top: 15px; text-align: center; display: flex; justify-content: center; align-items: center; gap: 10px;">
                        <label class="setting-item" style="padding:0; margin:0;">
                            <input type="checkbox" id="p2-ai-toggle">
                            <span>AI</span>
                        </label>
                        <button class="button" id="p2-key-config-btn">操作設定</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

<div id="game-container">
<div id="rule-description-display" style="display: none; position: absolute; z-index: 155; color: var(--font-color); background: rgba(26, 26, 46, 0.9); padding: 15px; border-radius: 10px; border: 2px solid #4b4b7c; font-family: var(--font-ui); font-size: 14px; max-width: 200px; max-height: 400px; overflow-y: auto; box-sizing: border-box; word-wrap: break-word; backdrop-filter: blur(4px);"></div>
<div id="ai-debug-display" style="display: none; position: absolute; z-index: 156; color: white; background: rgba(0,0,0,0.7); padding: 5px; font-family: monospace; font-size: 10px; left: 10px; top: 300px; max-height: 400px; overflow: auto;"></div>

<div id="ai-debug-controls" style="display: none; position: absolute; z-index: 156; color: white; background: rgba(0,0,0,0.7); padding: 5px; font-family: monospace; font-size: 12px;
left: 10px; top: 150px;">
    <input id="ai-debug-piece" placeholder="Piece (T)" size="3">
    <input id="ai-debug-x" placeholder="X" size="2">
    <input id="ai-debug-y" placeholder="Y" size="2">
    <input id="ai-debug-rot" placeholder="Rot" size="2">
    <button id="ai-debug-execute">Execute</button>
</div>
<div id="ai-tree-debug-display" style="display: none; position: fixed; z-index: 157; color: white; background: rgba(0,0,0,0.7); padding: 5px; font-family: monospace; font-size: 12px; left: 10px; top: 10px;"></div>
<canvas id="mainCanvas"></canvas>
<div id="scan-instructions" style="display: none;"></div>

        <div id="scan-controls" style="display: none; margin-top: 15px; gap: 10px; justify-content:center;">
             <button id="scanConfirmBtn" class="button">次へ</button>
             <button id="scanCancelBtn" class="button">キャンセル</button>
        </div>
    </div>
</div>

<div id="game-controls" style="display: none;
position: fixed; top: 10px; right: 10px; z-index: 160; gap: 10px;">
     <button id="retryBtn" class="button">リトライ</button>
     <button id="gameSettingsBtn" class="button">設定</button>
     <button id="backToEditorBtn" class="button">戻る</button>
</div>


<div id="virtual-controller-container">

    <div id="vc-edit-controls" style="display: none;">
        <button id="vc-save-and-close-btn" class="button">保存して閉じる</button>
    </div>
    <canvas id="virtualControllerCanvas"></canvas>
</div>

<div id="settings-modal">
    <div class="modal-content">
<div class="modal-tabs">
            <button class="tab-button active" data-tab="general">諸設定</button>
            <button class="tab-button" data-tab="p1-keys">1P操作設定</button>
            <button class="tab-button" data-tab="p2-keys" id="p2-keys-tab-btn" style="display: none;">2P操作設定</button>
            <button class="tab-button" data-tab="ai-settings">AI設定</button>
        </div>

        <div class="tab-content active" id="tab-content-general">
             <h2 style="margin-top: 20px;"></h2>
             <p></p>
             <div id="settings-list"></div>
        </div>

        <div class="tab-content" id="tab-content-p1-keys">
            <h2 style="margin-top: 20px;">PLAYER 1 - 操作設定</h2>
            <p></p>
            <div id="p1-key-config-list" class="key-config-list-container"></div>
            
            <h3><br>タッチ操作設定 (P1)</h3>
            <p></p>
                        <div id="p1-touch-mode-selection" style="display: flex;
justify-content: center; gap: 10px; margin-bottom: 15px;">
                <button class="button active" data-touch-mode="button">Button</button>
                <button class="button" data-touch-mode="draw">Draw</button>
            </div>
            <div id="p1-touch-draw-controls" style="display: none; margin-top: 15px; justify-content: center;">
                 <div class="setting-item" style="padding: 5px 15px; max-width: 300px;">
                    <label for="draw-move-delay-input">操作間隔 (ms)</label>
                    <input type="number" id="draw-move-delay-input" min="0" max="200" step="1" style="width: 80px; min-width: 80px;">
                </div>
            </div>
            <div class="modal-controls" id="p1-touch-button-controls" style="display: flex;
justify-content: center; gap: 10px; flex-wrap: wrap;">
                <button id="vc-edit-layout-btn" class="button">ボタン配置モードへ</button>
                <button id="vc-copy-layout-btn" class="button">配置をコピー</button>

                <button id="vc-paste-layout-btn" class="button">配置をインポート</button>
            </div>
        </div>
        
        <div class="tab-content" id="tab-content-p2-keys">
            <h2 style="margin-top: 20px;">PLAYER 2 - 操作設定</h2>
            <p></p>
            <div id="p2-key-config-list" class="key-config-list-container"></div>
        </div>

        <div class="tab-content" id="tab-content-ai-settings">
            <h2 style="margin-top: 20px;">AI設定</h2>
            <p></p>
            <div id="ai-settings-list" class="key-config-list-container"></div>
        </div>
        
        <div class="modal-controls" style="border-top: 1px solid var(--primary-color); padding-top: 15px; margin-top: 20px;">
            <button id="settings-close" class="button">保存して閉じる</button>
        </div>
    </div>
</div>

<div id="share-modal">
    <div class="modal-content">
        <h2>共有</h2>
        
        <div class="share-section">
            <h3>エクスポート</h3>
            <p></p>
            <div class="share-item">
                <span>共有リンク</span>
                <input type="text" id="share-link-input" readonly style="width: 100%; margin-top: 5px; margin-bottom: 5px; box-sizing: border-box;">
                <div style="display: flex; gap: 10px; margin-top: 5px;">
                    <button id="copy-link-btn" class="button">リンクをコピー</button>
                    <button id="advanced-link-btn" class="button">詳細なリンク生成</button>
                </div>
            </div>
            <div id="advanced-link-options" style="display: none; margin-top: 15px; padding: 10px; background-color: rgba(255,255,255,0.05); border-radius: 5px;">
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="start-sim-checkbox">
                        <span>シミュレーションを即スタート</span>
                    </label>
                </div>
<div class="setting-item">
                    <label>
                        <input type="checkbox" id="no-hold-checkbox">
                        <span>ホールドを禁止</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="hide-back-btn-checkbox" disabled>
                        <span>戻るボタンを非表示</span>
                    </label>
                </div>
                 <button id="generate-advanced-link-btn" class="button" style="margin-top: 10px;">リンクを再生成</button>
            </div>
        </div>
        
        <hr style="border-color: var(--primary-color); margin: 20px 0;">
        

        <div class="share-section">
            <h3>インポート</h3>
            <p></p>
            <button id="import-from-data-btn" class="button">クリップボードからインポート</button>
        </div>


        <div class="modal-controls">
            <button id="share-close" class="button">閉じる</button>
        </div>
    </div>
</div>

<div id="rule-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center; z-index: 200;">
    <div class="modal-content" style="width: 90%; max-width: 700px;">
        <h2>カスタムルール</h2>
        
        <div class="rule-section" style="margin-bottom: 20px;">
            <h3>説明</h3>
            <p style="font-size: 14px; color: #ccc; margin-top: 5px; margin-bottom: 10px;">ここに記述した内容は、ゲーム画面の左側（ホールドの下）に表示されます。</p>
            <textarea id="rule-description-input" style="width: 100%; height: 100px; background-color: var(--primary-color); color: var(--font-color); border: 1px solid var(--border-color); padding: 8px; border-radius: 4px; font-family: var(--font-ui); box-sizing: border-box; resize: vertical;"></textarea>
        </div>

        <div class="rule-section">
            <h3>コード (JS)</h3>
            <p style="font-size: 14px; color: #ccc; margin-top: 5px; margin-bottom: 10px;">ゲームのクリア・オーバー条件などをプログラムで定義します。</p>
            <textarea id="rule-code-input" style="width: 100%; height: 250px; background-color: var(--primary-color); color: var(--font-color); border: 1px solid var(--border-color); padding: 8px; border-radius: 4px; font-family: monospace; box-sizing: border-box; resize: vertical;"></textarea>
        </div>

        <div class="modal-controls" style="border-top: 1px solid var(--primary-color); padding-top: 15px; margin-top: 20px;">
            <button id="rule-save-close" class="button">保存して閉じる</button>
            <button id="rule-close" class="button">キャンセル</button>
        </div>
    </div>
</div>

<script>

const aiWorkerScript = `
const StandardWeights = {
    //盤面評価系
    back_to_back: 52,
    bumpiness: -24,
    bumpiness_sq: -7,
    row_transitions: -5,
    height: -39,
    top_half: -150,
    top_quarter: -511,
    jeopardy: -11,
    cavity_cells: -173,
    cavity_cells_sq: -3,
    overhang_cells: -34,
    overhang_cells_sq: -1,
    covered_cells: -17,
    covered_cells_sq: -1,
    tslot: [8, 148, 192, 407],
    well_depth: 57,
    max_well_depth: 17,
    well_column: [20, 23, 20, 50, 59, 21, 59, 10, -10, 24],

    // 行動評価系
    b2b_clear: 104,
    clear1: -263,
    clear2: -220,
    clear3: -178,
    clear4: 270,
    tspin1: 1,
    tspin2: 290,
    tspin3: 482,
    mini_tspin1: -158,
    mini_tspin2: -93,
    perfect_clear: 999,
    combo_garbage: 150,
    wasted_t: -152,

    //REN
    COMBO_GARBAGE: [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5],
};

const weights = StandardWeights;
const MOVE_DIGITS = 5;
const MAX_SEARCH_DEPTH = 15;
const PLAYFIELD_HEIGHT = 20;

//ホールド判定(おそらく全てのホールドに対応)
function judgeAvailableMinos(
    originalMinoSequence,
    usedMinos
) {
    const judge = [...originalMinoSequence];
    const remainingMinos = [...originalMinoSequence];
    for (const used_mino of usedMinos) {
        const it_index = remainingMinos.indexOf(used_mino);
        if (it_index !== -1) {
            remainingMinos.splice(it_index, 1); //最初に合致したものだけ削除
        }
    }

    //残ったミノの先頭2つを返す
    const available = [];
    if (remainingMinos.length > 0) available.push(remainingMinos[0]);
    if (remainingMinos.length >= 2) available.push(remainingMinos[1]);

    return available;
}

function makeID(baseID, moveIndex) {
  return baseID + String(moveIndex).padStart(MOVE_DIGITS, '0');
}

class TetrisBoard {
    static WIDTH = 10;
    static HEIGHT = 40;

    constructor(initialRows = null) {
        this.rows = new Uint16Array(TetrisBoard.HEIGHT).fill(0);
        if (initialRows) {
            for (let i = 0; i < TetrisBoard.HEIGHT; ++i) {
                this.rows[i] = initialRows[i];
            }
        }
    }

    clone() {
        const newBoard = new TetrisBoard();
        newBoard.rows.set(this.rows);
        return newBoard;
    }

    isFilled(row, col) {
        if (row < 0 || row >= TetrisBoard.HEIGHT || col < 0 || col >= TetrisBoard.WIDTH) return true;
        return (this.rows[row] & (1 << col)) !== 0;
    }

    fill(row, col) {
        if (row >= 0 && row < TetrisBoard.HEIGHT && col >= 0 && col < TetrisBoard.WIDTH) {
            this.rows[row] |= (1 << col);
        }
    }

    clear(row, col) {
        if (row >= 0 && row < TetrisBoard.HEIGHT && col >= 0 && col < TetrisBoard.WIDTH) {
            this.rows[row] &= ~(1 << col);
        }
    }

    isLineFull(row) {
        if (row < 0 || row >= TetrisBoard.HEIGHT) return false;
        return (this.rows[row] & ((1 << TetrisBoard.WIDTH) - 1)) === ((1 << TetrisBoard.WIDTH) - 1);
    }

    clearLine(targetRow) {
        if (targetRow < 0 || targetRow >= TetrisBoard.HEIGHT) return;
        for (let r = targetRow; r < TetrisBoard.HEIGHT - 1; ++r) {
            this.rows[r] = this.rows[r + 1];
        }
        this.rows[TetrisBoard.HEIGHT - 1] = 0;
    }

    clearFullLines() {
        let cleared = 0;
        let r = 0;
        while (r < TetrisBoard.HEIGHT) {
            if (this.isLineFull(r)) {
                this.clearLine(r);
                cleared++;
            } else {
                r++;
            }
        }
        return cleared;
    }
}


// Placement, Node are defined as plain objects.

let nodeMap = new Map();
let searchStartTime = 0;
let bestNodeIDAtDepth1 = "";
let maxEvaluationAtDepth1 = -Number.MAX_VALUE;

function propagateEvaluation(nodeID) {
    let currentPropagateTargetID = nodeID;

    while (nodeMap.has(currentPropagateTargetID)) {
        const S = nodeMap.get(currentPropagateTargetID);

        if (isDepthLevel(currentPropagateTargetID, 1)) {
            if (S.acc_eval + S.transient_eval > maxEvaluationAtDepth1) {
                maxEvaluationAtDepth1 = S.acc_eval + S.transient_eval;
                bestNodeIDAtDepth1 = currentPropagateTargetID;
            }
        }

        const parentID = S.parentID;
        if (parentID === undefined || !nodeMap.has(parentID)) {
            break;
        }

        const P = nodeMap.get(parentID);
        let max_value_from_children = -Number.MAX_VALUE;
        let parent_has_valid_children = false;

        if (P.childrenIDs.length > 0) {
            for (const child_id_of_P of P.childrenIDs) {
                if (nodeMap.has(child_id_of_P)) {
                    const child_node = nodeMap.get(child_id_of_P);
                    max_value_from_children = Math.max(max_value_from_children, child_node.acc_eval + child_node.transient_eval);
                    parent_has_valid_children = true;
                }
            }
        }

        if (parent_has_valid_children) {
            if (P.transient_eval < max_value_from_children) {
                P.transient_eval = max_value_from_children;
                currentPropagateTargetID = parentID;
            } else {
                break;
            }
        } else {
            break;
        }
    }
}

function getMinoShape(pieceType, rotation) {
    rotation = rotation % 4;
    switch (pieceType) { //間違えて(y,x)で作ってしまったので、後に辻褄合わせをしてある
        case 'I':
            if (rotation == 1|| rotation == 3) {
                return [[0,0], [0, 1], [0, 2], [0,3]];
            } else {
                return [[0,0], [1, 0], [2, 0], [3, 0]];
            }
        case 'O':
            return [[0,0], [1, 0], [0, 1], [1, 1]];
        case 'T':
            if (rotation == 1) return [[0,0], [0, -1], [0, 1], [1, 0]];
            if (rotation == 2) return [[0,0], [1, 0], [-1, 0], [0, -1]];
            if (rotation == 3) return [[0,0], [0, -1], [0, 1], [-1, 0]];
            if (rotation == 0) return [[0,0], [1, 0], [-1, 0], [0, 1]];
            break;
        case 'S':
            if (rotation == 1 || rotation == 3) return [[0,0], [1, -1], [1, 0], [0, 1]];
            if (rotation == 0 || rotation == 2) return [[0,0], [-1, 0], [1, 1], [0, 1]];
            break;
        case 'Z':
            if (rotation == 1 || rotation == 3) return [[0,0], [-1, -1], [-1, 0], [0, 1]];
            if (rotation == 0 || rotation == 2) return [[0,0], [1, 0], [-1, 1], [0, 1]];
            break;
        case 'J':
            if (rotation == 0) return [[0,0], [-1, 0], [1, 0], [-1, 1]];
            if (rotation == 1) return [[0,0], [0, -1], [1, 1], [0, 1]];
            if (rotation == 2) return [[0,0], [1, 0], [-1, 0], [1, -1]];
            if (rotation == 3) return [[0,0], [0, -1], [-1, -1], [0, 1]];
            break;
        case 'L':
            if (rotation == 0) return [[0,0], [-1, 0], [1, 0], [1, 1]];
            if (rotation == 1) return [[0,0], [0, -1], [1, -1], [0, 1]];
            if (rotation == 2) return [[0,0], [1, 0], [-1, 0], [-1, -1]];
            if (rotation == 3) return [[0,0], [0, -1], [-1, 1], [0, 1]];
            break;
        default:
            return [[0,0]];
    }
    return [[0,0]];
}

function checkCollision(board, pieceType, rotation, x_pivot, y_pivot) {
    const shapeWithPivot = getMinoShape(pieceType, rotation);

    for (const blockOffset of shapeWithPivot) {
        const blockY = y_pivot + blockOffset[1]; //辻褄合わせの為second(1)とfirst(0)を逆にしてるけどこれで正しい
        const blockX = x_pivot + blockOffset[0];

        if (board.isFilled(blockY, blockX)) {
            return true;
        }
    }
    return false;
}

function placeMinoOnBoard(board, pieceType, p) {
    const shapeWithPivot = getMinoShape(pieceType, p.rotation);
    for(const offset of shapeWithPivot) {
        board.fill(p.y + offset[1], p.x + offset[0]);//逆にしてるけどこれが正しい
    }
}

function getColumnHeights(board) {
    const heights = new Array(TetrisBoard.WIDTH).fill(0);
    for (let c = 0; c < TetrisBoard.WIDTH; ++c) {
        for (let r = TetrisBoard.HEIGHT - 1; r >= 0; --r) {
            if (board.isFilled(r, c)) {
                heights[c] = r + 1;
                break;
            }
        }
    }
    return heights;
}

function calculateBumpiness(board, wellColumn) {
    const heights = getColumnHeights(board);
    let bumpiness_val = 0;
    let bumpiness_sq_val = 0;
    let prev_col_idx;
    if (wellColumn === 0) {
        prev_col_idx = 1;
    } else {
        prev_col_idx = 0;
    }

    while (prev_col_idx < TetrisBoard.WIDTH && prev_col_idx === wellColumn) {
        prev_col_idx++;
    }
    if (prev_col_idx >= TetrisBoard.WIDTH) {
        return [0, 0];
    }
    let current_height = heights[prev_col_idx];

    for (let i = prev_col_idx + 1; i < TetrisBoard.WIDTH; ++i) {
        if (i === wellColumn) {
            continue;
        }
        const dh = Math.abs(heights[i] - current_height);
        bumpiness_val += dh;
        bumpiness_sq_val += dh * dh;
        current_height = heights[i];
    }
    return [bumpiness_val, bumpiness_sq_val];
}

function calculateCavitiesAndOverhangs(board) {
    const heights = getColumnHeights(board);
    let cavities = 0;
    let overhangs = 0;

    let max_board_height = 0;
    for (const h of heights) {
        max_board_height = Math.max(max_board_height, h);
    }
    if (max_board_height === 0) return [0,0];

    for (let y = 0; y < max_board_height; ++y) {
        for (let x = 0; x < TetrisBoard.WIDTH; ++x) {
            if (board.isFilled(y, x) || y >= heights[x]) {
                continue;
            }
            let counted_as_overhang = false;
            if (x > 1) {
                if (heights[x - 1] <= y && heights[x - 2] <= (y + 1)) {
                    overhangs++;
                    counted_as_overhang = true;
                }
            }
            if (counted_as_overhang) continue;
            if (x < TetrisBoard.WIDTH - 2) {
                if (heights[x + 1] <= y && heights[x + 2] <= (y + 1)) {
                    overhangs++;
                    counted_as_overhang = true;
                }
            }
            if (counted_as_overhang) continue;
            cavities++;
        }
    }
    return [cavities, overhangs];
}

function calculateCoveredCells(board) {
    const heights = getColumnHeights(board);
    let covered = 0;
    let covered_sq = 0;

    for (let x = 0; x < TetrisBoard.WIDTH; ++x) {
        if (heights[x] <= 1) {
            continue;
        }
        for (let y = heights[x] - 2; y >= 0; --y) {
            if (!board.isFilled(y, x)) {
                const cells_above_hole = heights[x] - (y + 1);
                const actual_cells_counted = Math.min(6, cells_above_hole);
                covered += actual_cells_counted;
                covered_sq += actual_cells_counted * actual_cells_counted;
            }
        }
    }
    return [covered, covered_sq];
}

function countSetBits(n) {
    let count = 0;
    while (n > 0) {
        n &= (n - 1);
        count++;
    }
    return count;
}

function calculateRowTransitions(board) {
     let rust_transitions = 0;
     for (let y = 0; y < TetrisBoard.HEIGHT; ++y) {
         const r = board.rows[y];
         const d = (r | (1 << TetrisBoard.WIDTH)) ^ (1 | (r << 1));
         rust_transitions += countSetBits(d);
     }
     return rust_transitions;
}

function calculateWell(board) {
    const heights = getColumnHeights(board);
    let well_col = -1;
    let min_h = TetrisBoard.HEIGHT + 1;

    for (let c = 0; c < TetrisBoard.WIDTH; ++c) {
        if (heights[c] < min_h) {
            min_h = heights[c];
            well_col = c;
        }
    }

    let depth = 0;
    if (well_col !== -1) {
        for (let y = heights[well_col]; y < TetrisBoard.HEIGHT; ++y) {
            let is_well_row = true;
            for (let x = 0; x < TetrisBoard.WIDTH; ++x) {
                if (x !== well_col && !board.isFilled(y, x)) {
                    is_well_row = false;
                    break;
                }
            }
            if (is_well_row) {
                depth++;
            } else {
                break;
            }
        }
    }
    depth = Math.min(depth, weights.max_well_depth);
    return [depth, well_col];
}

function check_sides(board, x, y) {
    for (let dx = 1; dx <= 9; ++dx) {
        if (x - dx < 0 || x + dx >= TetrisBoard.WIDTH) return false;
        if (!board.isFilled(y, x - dx) || !board.isFilled(y, x + dx)) {
            return false;
        }
    }
    return true;
}

function check_top(board, x, y) {
    for (let check_y = y + 1; check_y < 25; ++check_y) {
        if (board.isFilled(check_y, x)) {
            return false;
        }
    }
    return true;
}

function get_tslot_score(count) {
    if (count >= 3) return weights.tslot[3];
    if (count === 2) return weights.tslot[2];
    if (count === 1) return weights.tslot[1];
    return weights.tslot[0];
}

function calculateTslots(board) {
    let t_slot_score = 0.0;
    for (let y = 0; y < TetrisBoard.HEIGHT; ++y) {
        for (let x = 0; x < TetrisBoard.WIDTH; ++x) {
            const is_filled = (dx, dy) => {
                return board.isFilled(y + dy, x + dx);
            };

            // TSD
            if (!is_filled(-1, 0) && is_filled(1, -1) && is_filled(-1, -1) && is_filled(-1, 1)) {
                if (check_top(board, x, y) && check_top(board, x + 1, y)) {
                    let count = 0;
                    if (check_sides(board, x, y)) count++;
                    if (check_sides(board, x, y - 1)) count++;
                    t_slot_score += (count === 2) ? weights.tslot[2] : ((count === 1) ? weights.tslot[1] : weights.tslot[0]);
                }
            }
            // TSD
            if (!is_filled(1, 0) && is_filled(1, -1) && is_filled(-1, -1) && is_filled(1, 1)) {
                if (check_top(board, x, y) && check_top(board, x - 1, y)) {
                    let count = 0;
                    if (check_sides(board, x, y)) count++;
                    if (check_sides(board, x, y - 1)) count++;
                     t_slot_score += (count === 2) ? weights.tslot[2] : ((count === 1) ? weights.tslot[1] : weights.tslot[0]);
                }
            }
        }
    }
    return t_slot_score;
}

function isPerfectClear(board){
    return board.rows[0] === 0;
}

function evaluate(
    board,
    lastPlacement,
    linesCleared,
    isKick,
    softDropCount,
    currentCombo,
    currentB2BActive
){
    let acc_eval = 0.0;
    let transient_eval = 0.0;
    
    if (isPerfectClear(board) === true) acc_eval += weights.perfect_clear;

    if (true) {
        if (currentB2BActive && linesCleared > 0) {
            acc_eval += weights.b2b_clear;
        }
        if (currentCombo > 0) {
            const combo_idx = Math.min(currentCombo, weights.COMBO_GARBAGE.length - 1);
            acc_eval += weights.combo_garbage * weights.COMBO_GARBAGE[combo_idx];
        }

        if (isKick && lastPlacement.pieceType === 'T') {
            if (linesCleared === 1) acc_eval += weights.tspin1;
            else if (linesCleared === 2) acc_eval += weights.tspin2;
            else if (linesCleared === 3) acc_eval += weights.tspin3;
        } else if (isKick ) {
            if (linesCleared === 1) acc_eval += weights.clear1;
            else if (linesCleared === 2) acc_eval += weights.clear2;
            else if (linesCleared === 3) acc_eval += weights.clear3;
        }
        else {
            if (linesCleared === 1) acc_eval += weights.clear1;
            else if (linesCleared === 2) acc_eval += weights.clear2;
            else if (linesCleared === 3) acc_eval += weights.clear3;
            else if (linesCleared === 4) acc_eval += weights.clear4;
        }
    }

    if (lastPlacement.pieceType === 'T' && (linesCleared === 0 || !isKick)) {
        acc_eval += weights.wasted_t;
    }

    if (currentB2BActive) {
        transient_eval += weights.back_to_back;
    }

    const heights = getColumnHeights(board);
    let highest_point = 0;
    for(const h of heights) highest_point = Math.max(highest_point, h);

    transient_eval += weights.top_quarter * Math.max(0, highest_point - 15);
    transient_eval += weights.top_half * Math.max(0, highest_point - 10);
    transient_eval += weights.height * highest_point;
    transient_eval += weights.jeopardy * Math.max(0, highest_point - 10);
    transient_eval += calculateTslots(board);

    const [well_d, well_c] = calculateWell(board);
    transient_eval += weights.well_depth * well_d;
    if (well_d > 0 && well_c >= 0 && well_c < weights.well_column.length) {
        transient_eval += weights.well_column[well_c];
    }

    transient_eval += weights.row_transitions * calculateRowTransitions(board);

    const [bump, bump_sq] = calculateBumpiness(board, well_c);
    transient_eval += bump * weights.bumpiness;
    transient_eval += bump_sq * weights.bumpiness_sq;

    const [cav, over] = calculateCavitiesAndOverhangs(board);
    transient_eval += weights.cavity_cells * cav;
    transient_eval += weights.cavity_cells_sq * cav * cav;
    transient_eval += weights.overhang_cells * over;
    transient_eval += weights.overhang_cells_sq * over * over;

    const [cov, cov_sq] = calculateCoveredCells(board);
    transient_eval += weights.covered_cells * cov;
    transient_eval += weights.covered_cells_sq * cov_sq;

    return [acc_eval, transient_eval];
}

function createAndAddChildNode(
    parentNodeID,
    boardStateAtParent,
    p,
    isKick,
    childrenGenerated
) {
    if (!nodeMap.has(parentNodeID)) return;
    const parentNode = nodeMap.get(parentNodeID);
    
    const childID = makeID(parentNodeID, parentNode.childrenIDs.length);

    const childNode = {
        board: null,
        acc_eval: 0.0,
        transient_eval: -Number.MAX_VALUE,
        place: p,
        expanded: false,
        childrenIDs: [],
        parentID: parentNodeID,
        softDropCount: 0,
        comboCount: 0,
        B2B: false,
    };

    if (p.y >= PLAYFIELD_HEIGHT) childNode.softDropCount = 0;
    else childNode.softDropCount = Math.max(0, (PLAYFIELD_HEIGHT - 1) - p.y);

    const boardAfterPlace = boardStateAtParent.clone();
    placeMinoOnBoard(boardAfterPlace, p.pieceType, p);
    const linesCleared = boardAfterPlace.clearFullLines();

    childNode.board = boardAfterPlace;

    const parentActualNode = nodeMap.get(parentNodeID);

    if (linesCleared > 0) {
        childNode.comboCount = parentActualNode.comboCount + 1;
    } else {
        childNode.comboCount = 0;
    }

    const moveWasSpecialForB2B = (isKick && p.pieceType === 'T' && linesCleared > 0) || (linesCleared >= 4);
    if (moveWasSpecialForB2B) {
        childNode.B2B = true;
    } else {
        childNode.B2B = (linesCleared > 0) ? false : parentActualNode.B2B;
    }

    const [acc_val, transient_val] = evaluate(
        boardAfterPlace,
        p,
        linesCleared,
        isKick,
        childNode.softDropCount,
        childNode.comboCount,
        childNode.B2B
    );
    childNode.acc_eval = acc_val;
    childNode.transient_eval = transient_val;

    nodeMap.set(childID, childNode);
    nodeMap.get(parentNodeID).childrenIDs.push(childID);
    childrenGenerated.push([childID, p]);

    propagateEvaluation(childID);
}

function checkRotationKicks(
    board,
    x_pivot,
    y_pivot,
    pieceType,
    currentRotation,
    parentNodeID,
    childrenGenerated
) {
    let kickNodeCreated = false;
    const is_filled = (dx, dy) => {
        return board.isFilled(y_pivot + dy, x_pivot + dx);
    };

    if (pieceType === 'L' && currentRotation === 3) {
        if ((is_filled(0, -2) || is_filled(-1, -2) || is_filled(-2, -2))&& !is_filled(-2, -1) && !is_filled(-1, -1) && is_filled(-1, 0)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot - 1, y: y_pivot - 1, rotation: 0, pieceType: 'L'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }

    if (pieceType === 'J' && currentRotation === 1) {
        if ((is_filled(0, -2) || is_filled(1, -2) || is_filled(2, -2))&& !is_filled(2, -1) && !is_filled(1, -1) && is_filled(1, 0)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot + 1, y: y_pivot - 1, rotation: 0, pieceType: 'J'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'S' && currentRotation === 0) {
        if (is_filled(1, 0) && is_filled(0, -1) && is_filled(0, -4) &&
            !is_filled(-1, -1) && !is_filled(-1, -2) && !is_filled(0, -2) && !is_filled(0, -3)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot - 1, y: y_pivot - 2, rotation: 1, pieceType: 'S'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'Z' && currentRotation === 0) {
        if (is_filled(-1, 0) && is_filled(0, -1) && is_filled(0, -4) &&
            !is_filled(1, -1) && !is_filled(1, -2) && !is_filled(0, -2) && !is_filled(0, -3)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot + 1, y: y_pivot - 2, rotation: 1, pieceType: 'Z'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'S' && currentRotation === 1) {
        if (is_filled(0, -1) && (is_filled(0, -3) || is_filled(1, -3)) &&
            !is_filled(0, -2) && !is_filled(1, -2) && !is_filled(2, -1)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot + 1, y: y_pivot - 2, rotation: 0, pieceType: 'S'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'Z' && currentRotation === 1) {
        if (is_filled(0, -1) && (is_filled(0, -3) || is_filled(-1, -3)) &&
            !is_filled(0, -2) && !is_filled(-1, -2) && !is_filled(-2, -1)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot - 1, y: y_pivot - 2, rotation: 0, pieceType: 'Z'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'T' && currentRotation === 1) {
        if (!is_filled(-1, 0) && is_filled(1, -1) && is_filled(-1, -1) && is_filled(-1, 1)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot, y: y_pivot, rotation: 2, pieceType: 'T'}, true, childrenGenerated);
            createAndAddChildNode(parentNodeID, board, {x: x_pivot, y: y_pivot, rotation: 0, pieceType: 'T'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'T' && currentRotation === 3) {
        if (!is_filled(1, 0) && is_filled(1, -1) && is_filled(-1, -1) && is_filled(1, 1)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot, y: y_pivot, rotation: 2, pieceType: 'T'}, true, childrenGenerated);
            createAndAddChildNode(parentNodeID, board, {x: x_pivot, y: y_pivot, rotation: 0, pieceType: 'T'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'T' && currentRotation === 0) {
        if (!is_filled(2, -1) && !is_filled(2, -2) && !is_filled(2, -3) && !is_filled(1, -2) &&
            is_filled(2, 1) && is_filled(1, -1) && is_filled(2, -4)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot + 2, y: y_pivot - 2, rotation: 3, pieceType: 'T'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
        if (!is_filled(-2, -1) && !is_filled(-2, -2) && !is_filled(-2, -3) && !is_filled(-1, -2) &&
            is_filled(-2, 1) && is_filled(-1, -1) && is_filled(-2, -4)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot - 2, y: y_pivot - 2, rotation: 1, pieceType: 'T'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'T' && currentRotation === 1) { // TST Wall East
        if (!is_filled(2, -2) && !is_filled(2, -3) && !is_filled(2, -4) && !is_filled(1, -3) && !is_filled(2, -1) && !is_filled(1, -1) &&
            is_filled(2, 0) && is_filled(-1, 0) && is_filled(1, -2) && is_filled(2,-5)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot + 2, y: y_pivot - 3, rotation: 3, pieceType: 'T'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'T' && currentRotation === 3) { // TST Wall West
        if (!is_filled(-2, -2) && !is_filled(-2, -3) && !is_filled(-2, -4) && !is_filled(-1, -3) && !is_filled(-2, -1) && !is_filled(-1, -1) &&
            is_filled(-2, 0) && is_filled(1, 0) && is_filled(-1, -2) && is_filled(-2,-5)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot - 2, y: y_pivot - 3, rotation: 1, pieceType: 'T'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    return kickNodeCreated;
}

function expand(
    parentNodeID,
    boardStateAtParent,
    pieceToPlace,
    pathPlacementsToParent
) {
    const childrenGenerated = [];
    if (!nodeMap.has(parentNodeID)) return childrenGenerated;

    for (let x_pivot = -2; x_pivot < TetrisBoard.WIDTH + 2; ++x_pivot) {
        for (let r = 0; r < 4; ++r) {
            let skip_this_x_r_combination = false;

            if (pieceToPlace === 'O' && r > 0) continue;
            if ((pieceToPlace === 'I' || pieceToPlace === 'S' || pieceToPlace === 'Z') && r > 1) continue;

            let landing_y = -1;
            let max_relative_y = 0;
            for(const offset of getMinoShape(pieceToPlace, r)){
                if(offset[1] > max_relative_y) max_relative_y = offset[1];
            }
            let initial_y_candidate = PLAYFIELD_HEIGHT + max_relative_y;

            for (let y_candidate = initial_y_candidate; y_candidate >= -(TetrisBoard.HEIGHT - PLAYFIELD_HEIGHT) ; --y_candidate) {
                if (!checkCollision(boardStateAtParent, pieceToPlace, r, x_pivot, y_candidate)) {
                    if (checkCollision(boardStateAtParent, pieceToPlace, r, x_pivot, y_candidate - 1)) {
                        landing_y = y_candidate;
                        break;
                    }
                } else {
                    let all_blocks_above_playfield = true;
                    for(const offset of getMinoShape(pieceToPlace, r)){
                        if (y_candidate + offset[1] < PLAYFIELD_HEIGHT){
                            all_blocks_above_playfield = false;
                            break;
                        }
                    }
                    if (all_blocks_above_playfield && y_candidate >= PLAYFIELD_HEIGHT -1 - max_relative_y) {
                    } else if (y_candidate >= PLAYFIELD_HEIGHT -1 - max_relative_y) {
                        skip_this_x_r_combination = true;
                        break;
                    }
                }
            }

            if (skip_this_x_r_combination || landing_y === -1) {
                continue;
            }

            const kickNodeWasCreated = checkRotationKicks(
                boardStateAtParent,
                x_pivot,
                landing_y,
                pieceToPlace,
                r,
                parentNodeID,
                childrenGenerated
            );

            if (!kickNodeWasCreated) {
                 const currentPlacement = {x: x_pivot, y: landing_y, rotation: r, pieceType: pieceToPlace};
                 createAndAddChildNode(
                    parentNodeID,
                    boardStateAtParent,
                    currentPlacement,
                    false,
                    childrenGenerated
                 );
            }
        }
    }
    
    const parentNode = nodeMap.get(parentNodeID);
    if (parentNode && parentNode.childrenIDs.length > 0) {
        parentNode.expanded = true;
    }
    return childrenGenerated;
}

function isDepthLevel(id, depth) {
    return id.length === depth * MOVE_DIGITS;
}

function select(parentNodeID) {
    if (!nodeMap.has(parentNodeID)) {
        return "";
    }

    const children_ids = nodeMap.get(parentNodeID).childrenIDs;
    if (children_ids.length === 0) {
        return "";
    }

    const child_evals = [];
    let Emin = Number.MAX_VALUE;
    let first_valid_child = true;

    for (const id of children_ids) {
        if (nodeMap.has(id)) {
            const child_node = nodeMap.get(id);
            const current_eval = child_node.acc_eval + child_node.transient_eval;
            child_evals.push({id: id, eval: current_eval});
            if (first_valid_child) {
                Emin = current_eval;
                first_valid_child = false;
            } else {
                if (current_eval < Emin) {
                    Emin = current_eval;
                }
            }
        }
    }

    if (child_evals.length === 0) {
        return "";
    }

    child_evals.sort((a, b) => b.eval - a.eval);

    const weights_for_selection = [];
    let totalWeight = 0.0;

    for (let i = 0; i < child_evals.length; ++i) {
        const E_I = child_evals[i].eval;
        const rank_I = i + 1.0;
        const numerator = Math.pow(E_I - Emin + 1.0, 2) + 10.0;
        const denominator = Math.pow(rank_I - 1.0, 2) + 1.0;
        const weight_val = numerator / denominator;
        weights_for_selection.push(weight_val);
        totalWeight += weight_val;
    }

    if (totalWeight === 0.0 || child_evals.length === 0) {
        if (child_evals.length === 0) return "";
        return child_evals[0].id;
    }

    const r = Math.random() * totalWeight;

    let cumulativeWeight = 0.0;
    for (let i = 0; i < child_evals.length; ++i) {
        cumulativeWeight += weights_for_selection[i];
        if (r <= cumulativeWeight) {
            return child_evals[i].id;
        }
    }
    if (child_evals.length > 0) return child_evals[child_evals.length - 1].id;
    return "";
}

function runAI(initialBoard, minoSequence, isB2B, ren) {
    bestNodeIDAtDepth1 = "";
    maxEvaluationAtDepth1 = -Number.MAX_VALUE;
    searchStartTime = performance.now();

    const rootID = "";

    if (!nodeMap.has(rootID)) {
        const rootNodeSpecs = {
            board: null,
            acc_eval: 0.0,
            transient_eval: -Number.MAX_VALUE,
            place: {},
            expanded: false,
            childrenIDs: [],
            parentID: undefined,
            softDropCount: 0,
            comboCount: ren,
            B2B: isB2B,
        };
        nodeMap.set(rootID, rootNodeSpecs);
    }

    nodeMap.get(rootID).board = initialBoard;
    
    const availableMinos = judgeAvailableMinos(minoSequence, []);
    const expandedMinos = {};
    if(nodeMap.has(rootID)){
        for(const childId of nodeMap.get(rootID).childrenIDs){
            if(nodeMap.has(childId)){
                expandedMinos[nodeMap.get(childId).place.pieceType] = true;
            }
        }
    }
    for (const pieceForExpansion of availableMinos) {
        if (!expandedMinos[pieceForExpansion]) {
            expand(rootID, initialBoard, pieceForExpansion, []);
        }
    }

    if (nodeMap.has(rootID)) {
        for (const childID of nodeMap.get(rootID).childrenIDs) {
            if (nodeMap.has(childID)) {
                const childNode = nodeMap.get(childID);
                const current_child_eval = childNode.acc_eval + childNode.transient_eval;
                
                if (current_child_eval > maxEvaluationAtDepth1) {
                    maxEvaluationAtDepth1 = current_child_eval;
                    bestNodeIDAtDepth1 = childID;
                }
            }
        }
    }
}

function pruneAndReroot(chosenNodeID) {
    if (chosenNodeID === "" || !nodeMap.has(chosenNodeID)) {
        nodeMap.clear();
        return;
    }

    const new_nodeMap = new Map();
    const q = [chosenNodeID]; // Queue simulation

    const newRootNode = { ...nodeMap.get(chosenNodeID) };
    const newRootID = "";
    newRootNode.parentID = undefined; 
    
    const newChildrenIDs = [];
    for (const oldChildID of newRootNode.childrenIDs) {
        if (nodeMap.has(oldChildID)) {
            newChildrenIDs.push(oldChildID.substring(chosenNodeID.length));
        }
    }
    newRootNode.childrenIDs = newChildrenIDs;
    new_nodeMap.set(newRootID, newRootNode);

    while (q.length > 0) {
        const oldParentID = q.shift();
        const oldParentNode = nodeMap.get(oldParentID);

        for (const oldChildID of oldParentNode.childrenIDs) {
            if (!nodeMap.has(oldChildID)) {
                continue;
            }
            
            const newChildID = oldChildID.substring(chosenNodeID.length);
            const newParentID = oldParentID.substring(chosenNodeID.length);
            
            const newNode = { ...nodeMap.get(oldChildID) };
            newNode.parentID = newParentID;
            
            const newGrandChildrenIDs = [];
            for(const oldGrandChildID of newNode.childrenIDs) {
                 if (nodeMap.has(oldGrandChildID)) {
                    newGrandChildrenIDs.push(oldGrandChildID.substring(chosenNodeID.length));
                }
            }
            newNode.childrenIDs = newGrandChildrenIDs;
            
            new_nodeMap.set(newChildID, newNode);
            
            q.push(oldChildID);
        }
    }
    

    nodeMap = new_nodeMap;
}

function boardsAreEqual(board1, board2) {
    if (!board1 || !board2) return false;
    for (let i = 0; i < TetrisBoard.HEIGHT; i++) {
        if (board1.rows[i] !== board2.rows[i]) {
            return false;
        }
    }
    return true;
}

let isThinking = false;
let currentMinoSequence = [];

function thinkingLoop() {
    if (!isThinking) return;

    for (let i = 0; i < 100; i++) {
        const rootID = "";
        let selectedNodeID = rootID;
        let depthOfSelectedNode = 0;
        let placementsToSelectedNode = [];
        let usedMinosOnPath = [];
        while (nodeMap.has(selectedNodeID) && nodeMap.get(selectedNodeID).expanded) {
            if (depthOfSelectedNode >= MAX_SEARCH_DEPTH) {
                break;
            }
            const childNodeID = select(selectedNodeID);
            if (childNodeID === "" || !nodeMap.has(childNodeID)) {
                break;
            }
            placementsToSelectedNode.push(nodeMap.get(childNodeID).place);
            usedMinosOnPath.push(nodeMap.get(childNodeID).place.pieceType);
            selectedNodeID = childNodeID;
            depthOfSelectedNode++;
        }
        
        const selectedNode = nodeMap.get(selectedNodeID);
        if (selectedNode && !selectedNode.expanded) {
            if (depthOfSelectedNode < MAX_SEARCH_DEPTH) {
                const boardStateForExpansion = selectedNode.board;
                const availableMinosForExpand = judgeAvailableMinos(currentMinoSequence, usedMinosOnPath);
                if (availableMinosForExpand.length > 0) {
                    for (const pieceForExpansion of availableMinosForExpand) {
                        expand(selectedNodeID, boardStateForExpansion, pieceForExpansion, placementsToSelectedNode);
}
                }
            }
        }
    }

    self.postMessage({ type: 'nodeCount', count: nodeMap.size });
    setTimeout(thinkingLoop, 0);
}

self.onmessage = (e) => {
    const { type, boardString, nextString, isB2B, ren } = e.data;
if (type === 'start') {
        const createBoardFromLayout = (layout) => {
            const board = new TetrisBoard();
            const layoutHeight = layout.length;
            const boardHeight = TetrisBoard.HEIGHT;
            const width = TetrisBoard.WIDTH;
            for (let layoutY = 0; layoutY < layoutHeight; layoutY++) {
                const boardY = (boardHeight - 1) - layoutY;
                if (boardY < 0) continue;

                let rowValue = 0;
                const layoutRow = layout[layoutY];
                if (!layoutRow || !Array.isArray(layoutRow)) {
                    continue;
                }

                for (let x = 0; x < width; x++) {
                    if (layoutRow[x] !== null) {
                        rowValue |= (1 << x);
                    }
                }
                board.rows[boardY] = rowValue;
            }
            return board;
        };
        
        let initialLayout;
        try {
            initialLayout = JSON.parse(boardString);
        } catch (e) {
            console.error("Failed to parse boardString:", e);
            initialLayout = Array(TetrisBoard.HEIGHT).fill(null).map(() => Array(TetrisBoard.WIDTH).fill(null));
        }
        
                const board = createBoardFromLayout(initialLayout);
        
        const chosenNodeID = bestNodeIDAtDepth1;
        pruneAndReroot(chosenNodeID);

        const rootNode = nodeMap.get("");
        if (rootNode && rootNode.board && boardsAreEqual(rootNode.board, board)) {
            self.postMessage({type: 'debug', message: '探索木を引き継ぎました'});
        } else {
            nodeMap.clear();
            self.postMessage({type: 'debug', message: '探索木をリセットしました'});
        }
        currentMinoSequence = nextString.split('');
        runAI(board, currentMinoSequence, isB2B, ren);
        
        if (!isThinking) {
            isThinking = true;
            thinkingLoop();
        }


} else if (type === 'stop') {
        let bestMove = null;
        if (bestNodeIDAtDepth1 !== "" && nodeMap.has(bestNodeIDAtDepth1)) {
            bestMove = nodeMap.get(bestNodeIDAtDepth1).place;
            
            const rootNode = nodeMap.get("");
            if (rootNode) {
                for (const childId of rootNode.childrenIDs) {
                    if (nodeMap.has(childId)) {
                        const childNode = nodeMap.get(childId);
                        if (childId === bestNodeIDAtDepth1) {
                            childNode.acc_eval += 999999;
                        } else {
                            childNode.acc_eval -= 999999;
                        }
                    }
                }
            }
        } else {
            const rootNode = nodeMap.get("");
            if (rootNode && rootNode.childrenIDs.length > 0) {
                let bestFallbackID = "";
                let maxEvalFallback = -Number.MAX_VALUE;
                for(const childID of rootNode.childrenIDs){
                    if(nodeMap.has(childID)){
                        const child_node = nodeMap.get(childID);
                        const current_total_eval = child_node.acc_eval + child_node.transient_eval;
                        if(current_total_eval > maxEvalFallback){
                            maxEvalFallback = current_total_eval;
                            bestFallbackID = childID;
                        }
                    }
                }
                if(bestFallbackID !== ""){
                    bestMove = nodeMap.get(bestFallbackID).place;
                }
            }
        }
        
        if (bestMove && bestMove.pieceType !== ' ') {
            let finalX;
            let finalY;
            if (bestMove.pieceType === 'I' && bestMove.rotation === 1) {
                finalX = bestMove.x - 2;
                finalY = 37 - bestMove.y;
            } 
            else if (bestMove.pieceType === 'Z' && bestMove.rotation === 1) {
                finalX = bestMove.x - 1;
                finalY = 39 - bestMove.y;
            } 
            else {
                finalX = bestMove.x;
                finalY = 39 - bestMove.y;
            }
            self.postMessage({
                piece: bestMove.pieceType,
                x: finalX,
                y: finalY,
                rotation: bestMove.rotation,
            });
        } else {
            self.postMessage(null);
        }
    }

};
`;

const virtualController = (() => {

    let container, canvas, ctx, editControls;

    let mode = 'play';
    let layouts = {};
    let buttons = {};
    let selectedButtonId = null;
    let isDraggingButton = false;
    let isDraggingSlider = false;
    const activeTouches = {};

   
    const defaultLayout = {
        portrait: {
            'left':      { label: '←', x: 0.12, y: 0.82, r: 0.08 },
            'right':     { label: '→', x: 0.32, y: 0.82, r: 0.08 },
            'softDrop':  { label: '↓', x: 0.22, y: 0.92, r: 0.07 },
            'hardDrop':  { label: '↑', x: 0.22, y: 0.72, r: 0.07 },
            'rotateCCW': { label: 'L',  x: 0.65, y: 0.85, r: 0.10 },
            'rotateCW':  { label: 'R',  x: 0.85, y: 0.85, r: 0.10 },
            'hold':      { label: 'H',  x: 0.75, y: 0.68, r: 0.09 },
        },
        landscape: {
            'left':      { label: '←', x: 0.10, y: 0.75, r: 0.08 },
            'right':     { label: '→', x: 0.25, y: 0.75, r: 0.08 },
            'softDrop':  { label: '↓', x: 0.175,y: 0.90, r: 0.07 },
            'hardDrop':  { label: '↑', x: 0.175,y: 0.60, r: 0.07 },
            'rotateCCW': { label: 'L',  x: 0.80, y: 0.85, r: 0.10 },
            'rotateCW':  { label: 'R',  x: 0.90, y: 0.65, r: 0.10 },
            'hold':      { label: 'H',  x: 0.75, y: 0.60, r: 0.09 },
        }
    };
    
    function init() {
        container = document.getElementById('virtual-controller-container');
        canvas = document.getElementById('virtualControllerCanvas');
        ctx = canvas.getContext('2d');
        editControls = document.getElementById('vc-edit-controls');

        loadLayouts();
        handleResize();

        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', handleResize);

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleEnd, { passive: false });
        

        let isMouseDown = false;
        const convertMouseEvent = (e) => ({ changedTouches: [{ clientX: e.clientX, clientY: e.clientY, identifier: -1 }], preventDefault: () => {} });
        canvas.addEventListener('mousedown', (e) => { isMouseDown = true; handleStart(convertMouseEvent(e)); });
        canvas.addEventListener('mousemove', (e) => { if (isMouseDown) handleMove(convertMouseEvent(e)); });
        window.addEventListener('mouseup', (e) => { if (isMouseDown) { isMouseDown = false; handleEnd(convertMouseEvent(e)); } });
    }

    function show() { if (container) container.style.display = 'block'; handleResize(); }
    function hide() { if (container) container.style.display = 'none'; }

    function startEditMode() {
        show();
        mode = 'edit';
        editControls.style.display = 'flex';
        selectedButtonId = null;
        draw();
    }

    function endEditMode() {
        mode = 'play';
        editControls.style.display = 'none';
        saveLayouts();
        if (gameState !== 'PLAYING') {
            hide();
        }
        draw();
    }
    
    function handleResize() {
        if (!canvas) return;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const orientation = (canvas.width > canvas.height) ? 'landscape' : 'portrait';
       
        if (!layouts[orientation] || Object.keys(layouts[orientation]).length === 0) {
            layouts[orientation] = JSON.parse(JSON.stringify(defaultLayout[orientation]));
        }
        
        buttons = layouts[orientation];
       
        for(const id in buttons) {
            if (buttons[id].isPressed === undefined) {
                buttons[id].isPressed = false;
            }
        }
        
        draw();
    }

    function draw() {
        if (!ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const shortSide = Math.min(canvas.width, canvas.height);

        for (const id in buttons) {
            const btn = buttons[id];
            const x = btn.x * canvas.width;
            const y = btn.y * canvas.height;
            const r = btn.r * shortSide;

            ctx.beginPath();
            ctx.arc(x, y, r, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            if (btn.isPressed || (mode === 'edit' && id === selectedButtonId)) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();
            }
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.font = `bold ${r * 0.7}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(btn.label, x, y);
        }

        if (mode === 'edit' && selectedButtonId) {
            drawSizeSlider(shortSide);
        }
    }

    function drawSizeSlider(shortSide) {
        const centerX = canvas.width / 2;
        const y = canvas.height / 2;
        const sliderWidth = shortSide * 0.5;
        const minR = 0.04, maxR = 0.20;

        ctx.beginPath();
        ctx.moveTo(centerX - sliderWidth / 2, y);
        ctx.lineTo(centerX + sliderWidth / 2, y);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 5;
        ctx.stroke();

        const btn = buttons[selectedButtonId];
        const ratio = (btn.r - minR) / (maxR - minR);
        const handleX = (centerX - sliderWidth / 2) + sliderWidth * ratio;
        
        ctx.beginPath();
        ctx.arc(handleX, y, shortSide * 0.03, 0, 2 * Math.PI);
        ctx.fillStyle = 'white';
        ctx.fill();
    }

    function handleStart(e) {
        e.preventDefault();
        const touches = e.changedTouches;
        const shortSide = Math.min(canvas.width, canvas.height);

        for (let i = 0; i < touches.length; i++) {
            const touch = touches[i];
            const touchX = touch.clientX, touchY = touch.clientY;

            if (mode === 'play') {
                const buttonId = getButtonAt(touchX, touchY, shortSide);
                if (buttonId) {
                    pressButton(buttonId);
                    activeTouches[touch.identifier] = buttonId;
                }
            } else {
                const sliderHit = checkSliderHit(touchX, touchY, shortSide);
                if (sliderHit) {
                    isDraggingSlider = true;
                    activeTouches[touch.identifier] = 'slider';
                    updateSlider(touchX, shortSide);
                    return;
                }
                const buttonId = getButtonAt(touchX, touchY, shortSide);
                if (buttonId) {
                    selectedButtonId = buttonId;
                    isDraggingButton = true;
                    activeTouches[touch.identifier] = buttonId;
                } else {
                    selectedButtonId = null;
                }
            }
        }
        draw();
    }

    function handleMove(e) {
        e.preventDefault();
        const touches = e.changedTouches;
        const shortSide = Math.min(canvas.width, canvas.height);

        for (let i = 0; i < touches.length; i++) {
            const touch = touches[i];
            const touchId = touch.identifier;
            const touchX = touch.clientX, touchY = touch.clientY;

            if (mode === 'play') {
                const prevButtonId = activeTouches[touchId];
                const currentButtonId = getButtonAt(touchX, touchY, shortSide);
                if (prevButtonId !== currentButtonId) {
                    if (prevButtonId) releaseButton(prevButtonId);
                    if (currentButtonId) pressButton(currentButtonId);
                    activeTouches[touchId] = currentButtonId;
                }
            } else {
                if (isDraggingSlider && activeTouches[touchId] === 'slider') {
                    updateSlider(touchX, shortSide);
                } else if (isDraggingButton && activeTouches[touchId] === selectedButtonId) {
                    const btn = buttons[selectedButtonId];
                    btn.x = touchX / canvas.width;
                    btn.y = touchY / canvas.height;
                }
            }
        }
        draw();
    }

    function handleEnd(e) {
        e.preventDefault();
        const touches = e.changedTouches;
        for (let i = 0; i < touches.length; i++) {
            const touchId = touches[i].identifier;
            if (mode === 'play') {
                const buttonId = activeTouches[touchId];
                if (buttonId) releaseButton(buttonId);
            } else {
                if (isDraggingButton) isDraggingButton = false;
                if (isDraggingSlider) isDraggingSlider = false;
            }
            delete activeTouches[touchId];
        }
        draw();
    }

    function getButtonAt(x, y, shortSide) {
     
        const buttonIds = Object.keys(buttons).reverse();
        for (const id of buttonIds) {
            const btn = buttons[id];
            const btnX = btn.x * canvas.width;
            const btnY = btn.y * canvas.height;
            const btnR = btn.r * shortSide;
            if (Math.sqrt((x - btnX) ** 2 + (y - btnY) ** 2) <= btnR) {
                return id;
            }
        }
        return null;
    }

    function pressButton(id) {
        const btn = buttons[id];
        if (btn && !btn.isPressed) {
            btn.isPressed = true;

            if (['hardDrop', 'rotateCW', 'rotateCCW', 'hold'].includes(id)) {
                if(players.length > 0) players[0].handlePress(id);
            }
        }
    }
    
    function releaseButton(id) {
        const btn = buttons[id];
        if (btn) btn.isPressed = false;
    }

    function checkSliderHit(x, y, shortSide) {
        if (!selectedButtonId) return false;
        const centerX = canvas.width / 2, sliderY = canvas.height / 2;
        const sliderWidth = shortSide * 0.5, handleRadius = shortSide * 0.03;
        const minR = 0.04, maxR = 0.20;
        const ratio = (buttons[selectedButtonId].r - minR) / (maxR - minR);
        const handleX = (centerX - sliderWidth / 2) + sliderWidth * ratio;
        return Math.sqrt((x - handleX) ** 2 + (y - sliderY) ** 2) <= handleRadius;
    }

    function updateSlider(touchX, shortSide) {
        if (!selectedButtonId) return;
        const centerX = canvas.width / 2, sliderWidth = shortSide * 0.5;
        const sliderStart = centerX - sliderWidth / 2;
        const clampedX = Math.max(sliderStart, Math.min(touchX, sliderStart + sliderWidth));
        const newRatio = (clampedX - sliderStart) / sliderWidth;
        const minR = 0.04, maxR = 0.20;
        buttons[selectedButtonId].r = minR + (maxR - minR) * newRatio;
    }

    function saveLayouts() {
        try {
            localStorage.setItem('tetrisVirtualPadLayouts', JSON.stringify(layouts));
        } catch (e) {
            console.error("Failed to save virtual pad layouts:", e);
        }
    }

    function loadLayouts() {
        try {
            const savedLayouts = JSON.parse(localStorage.getItem('tetrisVirtualPadLayouts'));
            if (savedLayouts && savedLayouts.portrait && savedLayouts.landscape) {
                layouts = savedLayouts;
            } else {
                layouts = JSON.parse(JSON.stringify(defaultLayout));
            }
        } catch (e) {
            console.error("Failed to load virtual pad layouts:", e);
            layouts = JSON.parse(JSON.stringify(defaultLayout));
        }
    }

    async function copyLayoutsToClipboard() {
        try {
            await navigator.clipboard.writeText(JSON.stringify(layouts, null, 2));
            alert('ボタン配置をクリップボードにコピーしました。');
        } catch (err) {
            alert('コピーに失敗しました。');
            console.error('Failed to copy layouts: ', err);
        }
    }

    async function importLayoutsFromClipboard() {
        if (!confirm('クリップボードからボタン配置を読み込みますか？現在の配置は上書きされます。')) return;
        try {
            const text = await navigator.clipboard.readText();
            const newLayouts = JSON.parse(text);
            if (newLayouts && newLayouts.portrait && newLayouts.landscape) {
                layouts = newLayouts;
                saveLayouts();
                handleResize();
                alert('ボタン配置をインポートしました。');
            } else {
                alert('無効なデータ形式です。');
            }
        } catch (err) {
            alert('インポートに失敗しました。');
            console.error('Failed to paste layouts: ', err);
        }
    }
    
    return {
        init,
        show,
        hide,
        startEditMode,
        endEditMode,
        isButtonPressed: (action) => buttons[action]?.isPressed || false,
        copyLayoutsToClipboard,
        importLayoutsFromClipboard
    };
})();

const RESOLUTION_SCALE = 2;
const BLOCK_SIZE = 28;
const EDITOR_BLOCK_SIZE = 50;
const BOARD_WIDTH = 10;
const BOARD_VISIBLE_HEIGHT = 20;
const BOARD_HEIGHT = 40; 
const HOLD_AREA_WIDTH = 5 * BLOCK_SIZE;
const PLAYFIELD_WIDTH = BOARD_WIDTH * BLOCK_SIZE;
const NEXT_AREA_WIDTH = 5 * BLOCK_SIZE;
const PADDING = 20;
const PLAYER_CANVAS_WIDTH = HOLD_AREA_WIDTH + PLAYFIELD_WIDTH + NEXT_AREA_WIDTH + PADDING * 2;
const CANVAS_HEIGHT = (BOARD_VISIBLE_HEIGHT + 0.5) * BLOCK_SIZE;
const PLAYFIELD_X_OFFSET = HOLD_AREA_WIDTH + PADDING;
const AXIS_THRESHOLD = 0.8;

let gameSettings = {
    das: 140,
    arr: 30,
    sdf: 20,
    lineClearDelay: 0,
    gravity: 9999999,
    lockDelay: 9999999,
    garbageGrace: 1000,
    garbageRandomness: 0.3,
    maxNext: 8,
    showEffects: true,
    showTimer: false,
    touchControlsEnabled: 'ontouchstart' in window,
    touchControlType: 'button',
    aiMoveDelay: 30,
    aiSdfDelay: 30,
    drawMoveDelay: 30,
};


const DRAW_SHAPE_MAP = {
    "1,0;2,0;3,0": { type: "I", rot: 0, offset: [0, 0] },
    "0,1;0,2;0,3": { type: "I", rot: 1, offset: [2, -1] },
    "0,1;1,0;1,1": { type: "O", rot: 0, offset: [0, -1] },
    "-1,1;0,1;1,1": { type: "T", rot: 0, offset: [0, -1] },
    "0,1;0,2;1,1": { type: "T", rot: 1, offset: [0, -1] },
    "1,0;1,1;2,0": { type: "T", rot: 2, offset: [-1, 0] },
    "-1,1;0,1;0,2": { type: "T", rot: 3, offset: [0, -1] },
    "-1,1;-2,1;0,1": { type: "L", rot: 0, offset: [1, -1] },
    "0,1;0,2;1,2": { type: "L", rot: 1, offset: [0, -1] },
    "0,1;1,0;2,0": { type: "L", rot: 2, offset: [-1, 0] },
    "1,0;1,1;1,2": { type: "L", rot: 3, offset: [-1, -1] },
    "0,1;1,1;2,1": { type: "J", rot: 0, offset: [-1, -1] },
    "0,1;0,2;1,0": { type: "J", rot: 1, offset: [0, -1] },
    "1,0;2,0;2,1": { type: "J", rot: 2, offset: [-1, 0] },
    "-1,2;0,1;0,2": { type: "J", rot: 3, offset: [0, -1] 
},
    "-1,1;0,1;1,0": { type: "S", rot: 0, offset: [0, -1] },
    "0,1;1,1;1,2": { type: "S", rot: 1, offset: [0, -1] },
    "1,0;1,1;2,1": { type: "Z", rot: 0, offset: [-1, -1] },
    "-1,1;-1,2;0,1": { type: "Z", rot: 1, offset: [1, -1] },
};
const COLORS = { 'I': '#00f0f0', 'O': '#f0f000', 'T': '#a000f0', 'L': '#f0a000', 'J': '#0000f0', 'S': '#00f000', 'Z': '#f00000', 'G': '#999999', 'E': '#808080' };



const SCAN_COLOR_PALETTE = {
    'NULL': ['#000000', '#302838'],
    'G':    ['#999999', '#D8D8D8'],
    'I':    ['#019899', '#0199D5'],
    'O':    ['#999A02', '#F9B900'],
    'T':    ['#980099', '#871E88'],
    'L':    ['#996700', '#F56100'],
    'J':    ['#0000BB', '#004BA5'],
    'S':    ['#10971F', '#5CB523'],
    'Z':    ['#990000', '#DA1822']
};

const hexToRgb = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return { r, g, b };
};

const PARSED_SCAN_COLORS = {};
for (const key in SCAN_COLOR_PALETTE) {
    PARSED_SCAN_COLORS[key] = SCAN_COLOR_PALETTE[key].map(hexToRgb);
}


const SCAN_COLORS = { ...COLORS, 'O': '#999A02', 'L': '#f0a000' };
const MINO_SKINS = { default: COLORS };
let activeSkin = MINO_SKINS.default;

const EDITOR_COLORS = {...COLORS, 'EMPTY': '#000000'};
const TETROMINOS = {
    'I': { shape: [[0, 0], [1, 0], [2, 0], [3, 0]], center: [1.5, 0.5] }, 'O': { shape: [[0, 0], [1, 0], [0, -1], [1, -1]], center: [0.5, -0.5] },
    'T': { shape: [[0, 0], [-1, 0], [0, -1], [1, 0]], center: [0, 0] }, 'L': { shape: [[-1, 0], [0, 0], [1, 0], [1, -1]], center: [0, 0] },
    'J': { shape: [[0, 0], [-1, 0], [1, 0], [-1, -1]], center: [0, 0] }, 'S': { shape: [[1, -1], [-1, 0], [0, 0], [0, -1]], center: [0, 0] },
    'Z': { shape: [[0, 0], [1, 0], [0, -1], [-1, -1]], center: [0, 0] }
};
const SRS_OFFSETS = { "JLSTZ": { "0_1": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], "1_0": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]], "1_2": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]], "2_1": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], "2_3": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]], "3_2": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]], "3_0": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]], "0_3": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]], }, "I": { "0_1": [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]], "1_0": [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]], "1_2": [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]], "2_1": [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]], "2_3": [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]], "3_2": [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]], "3_0": [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]], "0_3": [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]], } };

let players = [], gameMode = '1P', gameState = 'EDITING', lastTime = 0, mainCanvas, ctx, aiWorkerBlob;

function updateAiDebugDisplay(payload) {
    const display = document.getElementById('ai-debug-display');
    if (!display) return;

    // 盤面データをJavaScriptの2D配列形式の文字列に変換します
    let boardArrayString = '[\n';
    for (let y = 0; y < payload.board.length; y++) {
        const row = payload.board[y];
        // 各セルを 'null' または引用符付きの文字列 ('G'など) に変換します
        const rowString = row.map(cell => cell === null ? 'null' : `"${cell}"`).join(', ');
        boardArrayString += `  [${rowString}]`;
        if (y < payload.board.length - 1) {
            boardArrayString += ',\n'; // 最終行以外はカンマと改行を追加
        }
    }
    boardArrayString += '\n]';

    // 表示用のHTMLを生成します。盤面部分はtextareaに置き換えます。
    display.innerHTML = `
        PlayerID: ${payload.playerId}<br>
        REN: ${payload.ren}, B2B: ${payload.isB2B}<br>
        Hold: ${payload.holdPiece || 'none'} (CanHold: ${payload.canHold})<br>
        Next: ${payload.minoSequence.join(', ')}<br>
        Board (2D Array):<br>
        <textarea readonly style="width: 95%; height: 150px; font-family: monospace; font-size: 10px; background: #222; color: #eee; border: 1px solid #555; resize: vertical;"></textarea>
    `;

    // innerHTMLで設定した後、textareaのvalueに文字列を代入することで、
    // 改行が正しく反映され、コピー可能な状態になります。
    display.querySelector('textarea').value = boardArrayString;
}

let keyBindings = {
    p1: {
        left:      { type: 'key', value: 'a',           label: 'a' },
        right:     { type: 'key', value: 'd',           label: 'd' },
        softDrop:  { type: 'key', value: 's',           label: 's' },
        hardDrop:  { type: 'key', value: ' ',           label: 'Space' },
        rotateCW:  { type: 'key', value: 'e',           label: 'e' },
        rotateCCW: { type: 'key', value: 'q',           label: 'q' },
        hold:      { type: 'key', value: 'w',           label: 'w' },
    },
    p2: {
        left:      { type: 'key', value: 'arrowleft',   label: 'ArrowLeft' },
        right:     { type: 'key', value: 'arrowright',  label: 'ArrowRight' },
        softDrop:  { type: 'key', value: 'arrowdown',   label: 'ArrowDown' },
        hardDrop:  { type: 'key', value: 'enter',       label: 'Enter' },
        rotateCW:  { type: 'key', value: 'arrowup',     label: 'ArrowUp' },
        rotateCCW: { type: 'key', value: '.',           label: '.' },
        hold:      { type: 'key', value: '/',           label: '/' },
    }
};
const keyActionLabels = {
    left: '左移動', right: '右移動', softDrop: 'ソフトドロップ',
    rotateCW: '右回転', rotateCCW: '左回転',
    hardDrop: 'ハードドロップ', hold: 'ホールド'
};
let isBindingKey = false, bindingPlayer = null, bindingAction = null;
let gamepads = {}, prevGamepads = {};

const editorData = {
    p1: { board: null, nextQueue: [], hold: null, viewY: BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT, activeColor: 'I', nextInsertionIndex: -1 },
    p2: { board: null, nextQueue: [], hold: null, viewY: BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT, activeColor: 'I', nextInsertionIndex: -1 },
    rule: { description: '', code: '' }
};

let scanState = { image: null, bottomLeft: null, topRight: null, currentMousePos: {x: 0, y: 0}, targetPlayerId: null, parsedColors: null };

function* createMinoGenerator(customQueue) {
    if (customQueue && customQueue.length > 0) {
        yield* customQueue;
    }
    const bag = [];
    const pieces = Object.keys(TETROMINOS);
    while (true) {
        if (bag.length === 0) {
            const newBag = [...pieces];
            for (let i = newBag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newBag[i], newBag[j]] = [newBag[j], newBag[i]];
            }
            bag.push(...newBag);
        }
        yield bag.shift();
    }
}

class Player {
    constructor(id, offsetX, keyBindings, padIndex, isAi = false) {
        this.id = id; this.offsetX = offsetX; this.keyBindings = keyBindings; this.padIndex = padIndex;
        this.isAi = isAi;
        this.isAiThinking = false;
        this.aiWorker = null;
        if (this.isAi) {
            this.aiWorker = new Worker(URL.createObjectURL(aiWorkerBlob));
            this.aiWorker.onmessage = (e) => {
                if (e.data && e.data.type === 'debug') {
                    const debugDisplay = document.getElementById('ai-tree-debug-display');
                    if (debugDisplay) {
                        debugDisplay.textContent = e.data.message;
                    }
                } else if (e.data && e.data.type === 'nodeCount') {
                    const debugDisplay = document.getElementById('ai-tree-debug-display');
                    if (debugDisplay) {
                        
                    }
} else if (gameState === 'PLAYING' && this.isAiThinking) {
                    
                    this.executeAiMove(e.data);
                }
            };
        }
        
        this.isDrawingOnBoard = false;
        this.drawnBlocks = new Map();
        this.customGhosts = [];

        this.keys = {};
        const pData = editorData[`p${id}`];


        this.initialHold = pData.hold;
        this.board = pData.board.map(row => [...row]);
        this.minoGenerator = createMinoGenerator(pData.nextQueue);
        this.opponent = null;
        this.holdDisabled = false;
        this.ruleHooks = {};
        this.gameApi = null;
        this.reset();
    }

reset() {
        this.player = { x: 0, y: 0, pieceType: null, rotation: 0 };
this.nextQueue = [];
        for (let i = 0; i < gameSettings.maxNext; i++) {
            this.nextQueue.push(this.minoGenerator.next().value);
}
        this.isExecutingSequence = false;
        this.drawnBlocks.clear();
        this.isDrawingOnBoard = false;
        this.customGhosts = [];
        this.holdPiece = this.initialHold;this.canHold = true;
this.gravityTimer = gameSettings.gravity; this.lockTimer = 0;

        this.dasTimer = 0; this.arrTimer = 0; this.sdfTimer = 0; this.dasDirection = 0;
        this.isGrounded = false; this.gameOver = false; this.isClearingLine = false; this.lineClearDelayTimer = 0;
        this.gameClear = false;

        this.stats = {
            tSpinSingle: 0, tSpinDouble: 0, tSpinTriple: 0,
            miniTSpinSingle: 0, miniTSpinDouble: 0,
            perfectClear: 0, tetris: 0, ren: -1
        };

        this.viewY = BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT;
        this.pendingGarbage = 0;this.garbageQueue = []; this.ren = -1; this.isB2B = false;
        this.lastMoveWasRotation = false;
        this.lastSrsKickIndex = -1;
        this.specialMoveText = [];
        this.specialMoveTextTimer = 0;
        this.customUIText = null;
        this.elapsedTimeText = '0:00.000';
        this.lastGarbageHoleX = -1;
        this.spawnNewPiece();
    }

    
    spawnNewPiece() {
        this.player.pieceType = this.nextQueue.shift();
        this.nextQueue.push(this.minoGenerator.next().value);
        
        this.player.rotation = 0;
        this.canHold = true;
        this.lastMoveWasRotation = false;
        this.player.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[this.player.pieceType].center[0]) -1;

        const shape = this.getShape(this.player.pieceType, this.player.rotation);
        this.player.y = 19;
        if (this.checkCollision(this.player.x, this.player.y, shape)) {
            this.player.y = 18;
            if (this.checkCollision(this.player.x, this.player.y, shape)) {

                 this.gameOver = true;
            }
        }
    }

    isActionPressed(action) {
        const binding = this.keyBindings[action];
        if (binding?.type === 'key' && this.keys[binding.value]) return true;
        
        if (this.padIndex !== null && gamepads[this.padIndex]) {
            if (binding?.type === 'pad_button' && gamepads[this.padIndex].buttons[binding.value]) return true;
            if (binding?.type === 'pad_axis') {
                const [axis, dir] = [parseInt(binding.value[0]), binding.value[1]];
                const axisValue = gamepads[this.padIndex].axes[axis];
                if ((dir === '+' && axisValue > AXIS_THRESHOLD) || (dir === '-' && axisValue < -AXIS_THRESHOLD)) return true;
            }
        }
        

        if (this.id === '1' && gameSettings.touchControlsEnabled && gameSettings.touchControlType === 'button') {
            if (virtualController.isButtonPressed(action)) return true;
        }

        return false;
    }

    handlePress(action) {
        if (this.gameOver || this.isClearingLine || this.isExecutingSequence) return;
switch (action) {
            case 'rotateCCW': this.rotate(-1); break;
case 'rotateCW':  this.rotate(1); break;

            case 'hardDrop':  this.hardDrop(); break;
            case 'hold':      this.hold(); break;
        }
    }
update(dt) {
        if (this.gameOver || this.gameClear || this.isExecutingSequence) return;
        if (this.specialMoveTextTimer > 0) {
            this.specialMoveTextTimer -= dt;
        }

        if (this.gameApi && typeof this.gameApi.getTime === 'function') {
            const totalMilliseconds = this.gameApi.getTime();
            const minutes = Math.floor(totalMilliseconds / 60000);
            const seconds = Math.floor((totalMilliseconds % 60000) / 1000);
            const milliseconds = Math.floor(totalMilliseconds % 1000);
            this.elapsedTimeText = `${minutes}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
        }

this.processGarbageQueue();
        const left = this.isActionPressed('left');
        const right = this.isActionPressed('right');

        const horizDir = left ? -1 : (right ? 1 : 0);
        if (horizDir !== 0) {
            if (this.dasDirection !== horizDir) { 
                this.dasTimer = 0;
                this.arrTimer = 0;
                if (!this.isClearingLine) this.move(horizDir, 0);
            } else { 
                this.dasTimer += dt;
                if (this.dasTimer >= gameSettings.das) {
                    if (gameSettings.arr === 0) {
                        if (!this.isClearingLine) {
                            let successfulMoves = 0;
                            while (!this.checkCollision(this.player.x + horizDir, this.player.y, this.getShape(this.player.pieceType, this.player.rotation))) {
                                this.player.x += horizDir;
                                successfulMoves++;
                            }
                            if (successfulMoves > 0) {
                               this.lockTimer = 0;
                               this.lastMoveWasRotation = false;
                            }
                        }
                    } else {
                        this.arrTimer += dt;
                        if (this.arrTimer >= gameSettings.arr) {
                            if (!this.isClearingLine) this.move(horizDir, 0);
                            this.arrTimer -= gameSettings.arr;
                        }
                    }
                }
            }
        }
        this.dasDirection = horizDir;

        if (this.isClearingLine) {
            this.lineClearDelayTimer -= dt;
if (this.lineClearDelayTimer <= 0) { 
                this.isClearingLine = false;
this.riseGarbage(); 
                if (this.nextQueue[0] === 'E') {
                    if (this.holdPiece) {
                        this.player.pieceType = this.holdPiece;
this.holdPiece = null;
                        this.canHold = false;
                        
                        this.player.rotation = 0;
                        this.lockTimer = 0;
                        this.lastMoveWasRotation = false;
this.player.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[this.player.pieceType].center[0]) -1;
                        const shape = this.getShape(this.player.pieceType, this.player.rotation);
                        this.player.y = 19;
if (this.checkCollision(this.player.x, this.player.y, shape)) {
                            this.player.y = 18;
if (this.checkCollision(this.player.x, this.player.y, shape)) {
                                 this.gameOver = true;
}
                        }
                        return;
} else {
                        this.gameOver = true;
return;
                    }
                }
                this.spawnNewPiece();
}
            return;
}

        if (this.isAi) {
            if (!this.isAiThinking) {
                this.requestAiMove();
}
            return;
}

        if (this.ruleHooks.onUpdate && typeof this.ruleHooks.onUpdate === 'function') {
            try {
                this.ruleHooks.onUpdate(this.gameApi, this);
} catch (e) {
                console.error("Rule error onUpdate:", e);
this.gameOver = true;
                return;
            }
        }
        if (this.gameOver || this.gameClear) return;
        if (this.isActionPressed('softDrop')) {
             if (gameSettings.sdf > 0) {
                this.sdfTimer += dt;
                if (this.sdfTimer >= gameSettings.sdf) {
                    this.move(0, 1);
                    this.sdfTimer -= gameSettings.sdf;
                }
             } else { 
                const ghostY = this.getGhostY();
                if (this.player.y < ghostY) {
                    this.player.y = ghostY;
                    this.lockTimer = 0;
                }
             }
        } else {
            this.sdfTimer = 0;
        }
        
        this.isGrounded = this.checkCollision(this.player.x, this.player.y + 1, this.getShape(this.player.pieceType, this.player.rotation));
        if (this.isGrounded) {
            this.lockTimer += dt;
            if (this.lockTimer >= gameSettings.lockDelay) {
                this.lockPiece();
            }
        } else {
            this.lockTimer = 0;
            if (!this.isActionPressed('softDrop')) {
                 if (gameSettings.gravity > 0) {
                    this.gravityTimer -= dt;
                    if (this.gravityTimer <= 0) {
                        this.move(0, 1, false);
                        this.gravityTimer += gameSettings.gravity;
                    }
                 } else { 
                    this.player.y = this.getGhostY();
                 }
            }
        }
    }
draw() {
        ctx.save(); ctx.translate(this.offsetX, 0);
        this.drawUI();

        ctx.save(); ctx.translate(PLAYFIELD_X_OFFSET, 0.5 * BLOCK_SIZE);
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, PLAYFIELD_WIDTH, CANVAS_HEIGHT);
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 0.5;
        for (let y = 0; y < BOARD_VISIBLE_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            }
        }
        ctx.strokeStyle = '#4b4b7c'; ctx.lineWidth = 2; ctx.strokeRect(1, 1, PLAYFIELD_WIDTH - 2, CANVAS_HEIGHT - 2);
        for (let y = 0; y < BOARD_VISIBLE_HEIGHT; y++) { for (let x = 0; x < BOARD_WIDTH; x++) { const boardY = y + this.viewY; if (this.board[boardY]?.[x]) { this.drawBlock(this.board[boardY][x], x * BLOCK_SIZE, y * BLOCK_SIZE); } } }


        if (!this.gameOver && !this.gameClear && !this.isClearingLine && this.player.pieceType) { const shape = this.getShape(this.player.pieceType, this.player.rotation);
const ghostY = this.getGhostY(); if (ghostY > this.player.y) this.drawPiece(shape, this.player.x, ghostY, this.player.pieceType, true); this.drawPiece(shape, this.player.x, this.player.y, this.player.pieceType, false);
}

        if (this.customGhosts.length > 0) {
            const ghostMap = new Map();
            this.customGhosts.forEach(ghost => {
                const key = `${ghost.x},${ghost.y}`;
                ghostMap.set(key, ghost.pieceType);
            });

            ghostMap.forEach((pieceType, key) => {
                if (pieceType !== null) {
                    const [x, y] = key.split(',').map(Number);
                    const screenY = y - this.viewY;
                    if (screenY >= 0 && screenY < BOARD_VISIBLE_HEIGHT) {
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = activeSkin[pieceType] || '#FFF';
                        ctx.fillRect(x * BLOCK_SIZE, screenY * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        ctx.globalAlpha = 1.0;
                    }
                }
            });
        }

        if (this.drawnBlocks.size > 0) {
            ctx.fillStyle = '#FFFFFF';
ctx.globalAlpha = 0.8;
            for (const key of this.drawnBlocks.keys()) {

                const [x, y] = key.split(',').map(Number);
                const screenY = y - this.viewY;
                if (screenY >= 0 && screenY < BOARD_VISIBLE_HEIGHT) {
                    ctx.fillRect(x * BLOCK_SIZE, screenY * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                }
            }
            ctx.globalAlpha = 1.0;
        }
        this.drawSpecialMoveText();
        if (this.gameOver) this.drawMessage("GAME OVER");
        else if (this.gameClear) this.drawMessage("CLEAR!");
        ctx.restore(); ctx.restore();
    }
    
    getShape(p, r) { if(!p) return []; const o=TETROMINOS[p].shape; if(r===0||p==='O')return o; const c=TETROMINOS[p].center; return o.map(b=>{let [x,y]=[b[0]-c[0],b[1]-c[1]]; for(let i=0;i<r;i++){[x,y]=[-y,x];} return [x+c[0]+(p==='O'?0.5:0),y+c[1]+(p==='O'?0.5:0)];});}
    checkCollision(x,y,s) { for(const b of s) { const bx=Math.floor(x+b[0]), by=Math.floor(y+b[1]); if(bx<0||bx>=BOARD_WIDTH||by>=BOARD_HEIGHT||(by>=0&&this.board[by]?.[bx])) return true; } return false; }
    rotate(d) { if(this.gameOver||!this.player.pieceType||this.player.pieceType==='O')return; const oR=this.player.rotation, nR=(oR+d+4)%4; const oD=(this.player.pieceType==='I'?SRS_OFFSETS.I:SRS_OFFSETS.JLSTZ)[`${oR}_${nR}`]; const nS=this.getShape(this.player.pieceType,nR); for(let i=0;i<oD.length;i++){const t=oD[i];const oX=t[0],oY=-t[1]; if(!this.checkCollision(this.player.x+oX,this.player.y+oY,nS)){this.player.x+=oX;this.player.y+=oY;this.player.rotation=nR;this.lockTimer=0;this.lastMoveWasRotation=true;this.lastSrsKickIndex=i;return;}}}
    move(dx,dy,isPlayer=true) { if(this.gameOver||!this.player.pieceType)return; const s=this.getShape(this.player.pieceType,this.player.rotation); if(!this.checkCollision(this.player.x+dx,this.player.y+dy,s)){this.player.x+=dx;this.player.y+=dy;if(isPlayer){this.lockTimer=0;this.lastMoveWasRotation=false;}}}
    getGhostY() {if(!this.player.pieceType) return this.player.y; const s=this.getShape(this.player.pieceType,this.player.rotation); let y=this.player.y; while(!this.checkCollision(this.player.x,y+1,s))y++; return y;}
    
    hardDrop() {
        if (this.gameOver) return;
        const originalY = this.player.y;
        this.player.y = this.getGhostY();
        if (this.player.y > originalY) {
            this.lastMoveWasRotation = false;
        }
        this.lockPiece();
    }
    
hold() {
        if (this.gameOver || !this.canHold || this.holdDisabled) return;

        if (!this.holdPiece && this.nextQueue[0] === 'E') {
            return;
        }

        this.canHold = false;
        this.lastMoveWasRotation = false;
        if (this.holdPiece) {
            [this.player.pieceType, this.holdPiece] = [this.holdPiece, this.player.pieceType];
            this.player.rotation = 0;
            this.lockTimer = 0;
            
            this.player.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[this.player.pieceType].center[0]) -1;
            const shape = this.getShape(this.player.pieceType, this.player.rotation);
            this.player.y = 19;
            if (this.checkCollision(this.player.x, this.player.y, shape)) {
                this.player.y = 18;
                if (this.checkCollision(this.player.x, this.player.y, shape)) {
                     this.gameOver = true;
                }
            }
        } else {
            this.holdPiece = this.player.pieceType;
            this.spawnNewPiece();
        }
    }

lockPiece() {
        if (!this.player.pieceType) return;
        
        let tspinResult = this.checkForTSpin();

        const shape = this.getShape(this.player.pieceType, this.player.rotation);
        this.specialMoveText = [];
        let moveText = '';

        for (const b of shape) { const bx = Math.floor(this.player.x + b[0]), by = Math.floor(this.player.y + b[1]); if (by >= 0) this.board[by][bx] = this.player.pieceType; }
        
        const lines = this.clearLines();
        const isPC = lines > 0 && this.board.every(row => row.every(cell => cell === null));
        
        let attack = 0;
        let isAction = false;
        let moveInfo = { name: '', isPC: false, clearedLines: lines, isB2B: false, ren: this.ren, TSpinType: tspinResult };
        
        if (isPC) {
            attack = 10;
            isAction = true;
            this.stats.perfectClear++;
            moveInfo.isPC = true;
            this.ren++;
            this.isB2B = true;
            this.specialMoveText.push("PERFECT CLEAR");
        } else if (lines > 0) {
            isAction = true; this.ren++;
            
            if (tspinResult === 'TSPIN') {
                attack = [0, 2, 4, 6][lines];
                moveText = ['', 'T-Spin Single', 'T-Spin Double', 'T-Spin Triple'][lines];
                moveInfo.name = moveText;
                if (lines === 1) this.stats.tSpinSingle++;
                if (lines === 2) this.stats.tSpinDouble++;
                if (lines === 3) this.stats.tSpinTriple++;
            } else if (tspinResult === 'MINI_TSPIN') {
                attack = [0, 0, 1, 2, 4][lines];
                moveText = ['', 'T-Spin Mini Single', 'T-Spin Mini Double'][lines] || 'T-Spin Mini';
                moveInfo.name = moveText;
                if (lines === 1) this.stats.miniTSpinSingle++;
                if (lines === 2) this.stats.miniTSpinDouble++;
            } else {
                attack = [0, 0, 1, 2, 4][lines];
                moveText = ['', 'Single', 'Double', 'Triple', 'Tetris'][lines];
                moveInfo.name = moveText;
                if (lines === 4) this.stats.tetris++;
            }
            
            const isB2BEligible = (lines === 4) || (tspinResult && lines > 0);
            if (isB2BEligible) {
                if (this.isB2B) {
                    attack++;
                    this.specialMoveText.push("Back-to-Back");
                    moveInfo.isB2B = true;
                }
                this.isB2B = true;
            } else {
                this.isB2B = false;
            }
            const renBonus = [0,0,1,1,2,2,3,3,4,4,4,4,4,5][Math.min(this.ren, 13)];
            if(renBonus > 0) {
                attack += renBonus;
            }
            if (this.ren >= 1) {
                 this.specialMoveText.push(`${this.ren} REN`);
            }
            this.stats.ren = this.ren;
        } else if (tspinResult) {
            isAction = false; 
            this.ren = -1;
            this.isB2B = false; 
            moveText = (tspinResult === 'MINI_TSPIN') ? 'T-Spin Mini' : 'T-Spin';
        }
        
        if (!isAction) {
            this.ren = -1;
            this.stats.ren = -1;
        }
        if (moveText) this.specialMoveText.push(moveText);

        if (this.opponent && attack > 0) {
            let remainingAttack = attack;
             if (isPC) {
                this.opponent.addGarbage(remainingAttack);
            } else {
                if (this.pendingGarbage > 0) { const offset = Math.min(this.pendingGarbage, remainingAttack); this.pendingGarbage -= offset; remainingAttack -= offset; }
                if (remainingAttack > 0) { for (let i=0; i < this.garbageQueue.length && remainingAttack > 0; i++) { const offset = Math.min(this.garbageQueue[i].lines, remainingAttack); this.garbageQueue[i].lines -= offset; remainingAttack -= offset; } this.garbageQueue = this.garbageQueue.filter(g => g.lines > 0); }
                if (remainingAttack > 0) { this.opponent.addGarbage(remainingAttack); }
            }
        }
        
        if (this.ruleHooks.onPieceLock && typeof this.ruleHooks.onPieceLock === 'function') {
             try {
                this.ruleHooks.onPieceLock(this.gameApi, this, moveInfo);
            } catch (e) {
                console.error("Rule error onPieceLock:", e);
                this.gameOver = true;
            }
        }
        if (this.gameOver || this.gameClear) return;


if (this.specialMoveText.length > 0) {
            this.specialMoveTextTimer = 1500;
        }

        if (this.nextQueue[0] === 'E') {    
            if (this.holdPiece) {
                this.player.pieceType = this.holdPiece;
                this.holdPiece = null;
                this.canHold = false;
                
                this.player.rotation = 0;
                this.lockTimer = 0;
                this.lastMoveWasRotation = false;
                this.player.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[this.player.pieceType].center[0]) -1;
                const shape = this.getShape(this.player.pieceType, this.player.rotation);
                this.player.y = 19;
                if (this.checkCollision(this.player.x, this.player.y, shape)) {
                    this.player.y = 18;
                    if (this.checkCollision(this.player.x, this.player.y, shape)) {
                         this.gameOver = true;
                    }
                }
                return;
            } else {
                this.gameOver = true;
                return;
            }
        }

        this.lockTimer = 0;
        if (lines > 0) { this.isClearingLine = true; this.lineClearDelayTimer = gameSettings.lineClearDelay; } 
        else { this.riseGarbage(); this.spawnNewPiece(); }
    }
    
    checkForTSpin() {
        if (this.player.pieceType !== 'T' || !this.lastMoveWasRotation) return null;
        const centerX = this.player.x + TETROMINOS['T'].center[0];
        const centerY = this.player.y + TETROMINOS['T'].center[1];
        const corners = [[-1, -1], [1, -1], [-1, 1], [1, 1]];
        let occupiedCorners = 0;
        corners.forEach(([cx, cy]) => {
            const boardX = Math.round(centerX + cx);
            const boardY = Math.round(centerY + cy);
            if (boardX < 0 || boardX >= BOARD_WIDTH || boardY < 0 || boardY >= BOARD_HEIGHT || this.board[boardY]?.[boardX]) occupiedCorners++;
        });
        if (occupiedCorners < 3) return null;
        const frontCornerDefs = { 0: [[-1, -1], [1, -1]], 1: [[1, -1], [1, 1]], 2: [[-1, 1], [1, 1]], 3: [[-1, -1], [-1, 1]] };
        const frontCorners = frontCornerDefs[this.player.rotation];
        let occupiedFrontCorners = 0;
        frontCorners.forEach(([cx, cy]) => {
            const boardX = Math.round(centerX + cx);
            const boardY = Math.round(centerY + cy);
            if (boardX < 0 || boardX >= BOARD_WIDTH || boardY < 0 || boardY >= BOARD_HEIGHT || this.board[boardY]?.[boardX]) occupiedFrontCorners++;
        });
                if (occupiedFrontCorners === 2 || this.lastSrsKickIndex === 4) return 'TSPIN';
        return 'MINI_TSPIN';
    }

    clearLines() {
        const clearedLinesY = [];
        for (let y = 0; y < this.board.length; y++) {
            if (this.board[y].every(c => c !== null)) {
                clearedLinesY.push(y);
            }
        }

        if (clearedLinesY.length === 0) {
            return 0;
        }

        this.customGhosts = this.customGhosts.filter(ghost => !clearedLinesY.includes(ghost.y));

        this.customGhosts.forEach(ghost => {
            const linesClearedBelow = clearedLinesY.filter(clearedY => clearedY > ghost.y).length;
            if (linesClearedBelow > 0) {
                ghost.y += linesClearedBelow;
            }
        });

        const newBoard = this.board.filter((row, y) => !clearedLinesY.includes(y));
        const clearedCount = clearedLinesY.length;

        for (let i = 0; i < clearedCount; i++) {
            newBoard.unshift(Array(BOARD_WIDTH).fill(null));
        }
        this.board = newBoard;

        return clearedCount;
    }
    addGarbage(lines) { if (this.opponent) { this.garbageQueue.push({ lines, receivedTime: performance.now() });} }
    processGarbageQueue() { const now = performance.now(); for (let i = this.garbageQueue.length - 1; i >= 0; i--) { if (now - this.garbageQueue[i].receivedTime > gameSettings.garbageGrace) { this.pendingGarbage += this.garbageQueue[i].lines; this.garbageQueue.splice(i, 1); } } }
    
    riseGarbage() {
        if (this.pendingGarbage <= 0) return;
        
        if (this.lastGarbageHoleX === -1) {
            this.lastGarbageHoleX = Math.floor(Math.random() * BOARD_WIDTH);
        }
        
        for (let i = 0; i < this.pendingGarbage; i++) {
            if (this.board[0].some(cell => cell !== null)) {
                this.gameOver = true;
                return;
            }
            if (Math.random() < gameSettings.garbageRandomness) {
                this.lastGarbageHoleX = Math.floor(Math.random() * BOARD_WIDTH);
            }
            
            this.board.shift();
            const newRow = Array(BOARD_WIDTH).fill('G');
            newRow[this.lastGarbageHoleX] = null;
            this.board.push(newRow);
        }
        this.pendingGarbage = 0;
    }

    drawBlock(p,x,y,isGhost=false) {
        if(y<-BLOCK_SIZE)return;
        ctx.fillStyle=activeSkin[p]||'#FFF';
        ctx.globalAlpha=isGhost?0.3:1.0;
        ctx.fillRect(x,y,BLOCK_SIZE,BLOCK_SIZE);
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(x,y,BLOCK_SIZE,BLOCK_SIZE);
        ctx.globalAlpha=1.0;
    }

drawPiece(s,x,y,p,g) {s.forEach(b=>{const px=Math.floor(x+b[0])*BLOCK_SIZE, py=(Math.floor(y+b[1])-this.viewY)*BLOCK_SIZE; this.drawBlock(p,px,py,g);});}
    drawUI() {
        ctx.textAlign = 'center'; ctx.fillStyle = '#FFF'; ctx.font = `bold ${BLOCK_SIZE * 0.8}px "Orbitron"`;
        if (!this.holdDisabled) {
            ctx.fillText('HOLD', HOLD_AREA_WIDTH / 2, 40);
            if (this.holdPiece) { const s = this.getShape(this.holdPiece, 0); s.forEach(b => { const px = (HOLD_AREA_WIDTH / 2) - (TETROMINOS[this.holdPiece].center[0] * BLOCK_SIZE) + (b[0] * BLOCK_SIZE), py = 70 - (TETROMINOS[this.holdPiece].center[1] * BLOCK_SIZE) + (b[1] * BLOCK_SIZE); this.drawBlock(this.holdPiece, px, py); }); }
        }
        
const meterX = PLAYFIELD_X_OFFSET - 12;
        const meterWidth = 8; const meterMaxHeight = BOARD_VISIBLE_HEIGHT * BLOCK_SIZE;
        const pendingHeight = Math.min(this.pendingGarbage, BOARD_VISIBLE_HEIGHT) * BLOCK_SIZE;
        if (pendingHeight > 0) { ctx.fillStyle = 'red'; ctx.fillRect(meterX, meterMaxHeight - pendingHeight + (0.5 * BLOCK_SIZE), meterWidth, pendingHeight);
        }
        const queuedLines = this.garbageQueue.reduce((sum, g) => sum + g.lines, 0);
        const queuedHeight = Math.min(queuedLines, BOARD_VISIBLE_HEIGHT - this.pendingGarbage) * BLOCK_SIZE;
        if (queuedHeight > 0) { ctx.fillStyle = 'yellow';

ctx.fillRect(meterX, meterMaxHeight - pendingHeight - queuedHeight + (0.5*BLOCK_SIZE), meterWidth, queuedHeight);
}
                if (this.customUIText !== null) {
            ctx.font = `bold ${BLOCK_SIZE * 1.6}px "Orbitron"`;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(this.customUIText, HOLD_AREA_WIDTH / 2, 300);
            ctx.font = `bold ${BLOCK_SIZE * 1.2}px "Orbitron"`;
        }

        if (gameSettings.showTimer) {
            ctx.fillStyle = '#FFFFFF';
            ctx.font = `bold ${BLOCK_SIZE * 0.8}px "Orbitron"`;
const charSpacing = BLOCK_SIZE * 0.6;
            const totalWidth = this.elapsedTimeText.length * charSpacing;
let startX = (HOLD_AREA_WIDTH / 2) - (totalWidth / 2) + 15;
for (let i = 0; i < this.elapsedTimeText.length - 1; i++) {
                const char = this.elapsedTimeText[i];
const charX = startX + (i * charSpacing) + (charSpacing / 2);
                ctx.fillText(char, charX, CANVAS_HEIGHT - 20);
}
        }

        ctx.fillStyle = '#FFF';
const rX = PLAYFIELD_X_OFFSET + PLAYFIELD_WIDTH + PADDING + NEXT_AREA_WIDTH / 2;

        ctx.fillText('NEXT', rX, 40);



        for (let i = 0; i < gameSettings.maxNext; i++) {
            const pT = this.nextQueue[i];
            if (!pT) continue;
            if (pT === 'E') break;
            const s = this.getShape(pT, 0);
            s.forEach(b => {
                const px = rX - (TETROMINOS[pT].center[0] * BLOCK_SIZE) + (b[0] * BLOCK_SIZE);
                const py = 70 + (i * BLOCK_SIZE * 2.5) - (TETROMINOS[pT].center[1] * BLOCK_SIZE) + (b[1] * BLOCK_SIZE);
                this.drawBlock(pT, px, py);
            });
        }
    }
    
    drawSpecialMoveText() {
        if (this.specialMoveTextTimer <= 0 || this.specialMoveText.length === 0 || !gameSettings.showEffects) return;
        
        const centerX = PLAYFIELD_WIDTH / 2;
        const startY = CANVAS_HEIGHT / 2 - (this.specialMoveText.length * 18);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        for (let i = 0; i < this.specialMoveText.length; i++) {
            const text = this.specialMoveText[i];
            const y = startY + (i * 35);
            
            ctx.font = `bold ${BLOCK_SIZE}px "Orbitron"`;
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 4;

            ctx.strokeText(text, centerX, y);
            ctx.fillText(text, centerX, y);
        }
        ctx.textBaseline = 'alphabetic';
    }

drawMessage(t) { const cX = PLAYFIELD_WIDTH / 2; const cY = CANVAS_HEIGHT / 2; ctx.fillStyle = 'rgba(0,0,0,0.75)'; ctx.fillRect(0, -0.5*BLOCK_SIZE, PLAYFIELD_WIDTH, CANVAS_HEIGHT); ctx.fillStyle = '#FFF'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = `bold ${BLOCK_SIZE * 1.5}px "Orbitron"`; ctx.fillText(t, cX, cY); ctx.textBaseline = 'alphabetic'; }

requestAiMove() {
        this.isAiThinking = true; 
        const debugPayload = {
            playerId: this.id,
            board: this.board,
            minoSequence: [this.player.pieceType, ...this.nextQueue],
            holdPiece: this.holdPiece,
            canHold: this.canHold,
            isB2B: this.isB2B,
            ren: this.ren
        };
        updateAiDebugDisplay(debugPayload);

        let boardString = '[\n';
        for (let y = 0; y < this.board.length; y++) {
            const row = this.board[y];
            const rowString = row.map(cell => cell === null ? 'null' : `"${cell}"`).join(', ');
            boardString += `  [${rowString}]`;
            if (y < this.board.length - 1) {
                boardString += ',\n';
            }
        }
        boardString += '\n]';
        let nextPiecesForWorker;
        if (this.holdPiece) {
            nextPiecesForWorker = [this.holdPiece, this.player.pieceType, ...this.nextQueue];
        } else {
            nextPiecesForWorker = [this.player.pieceType, ...this.nextQueue];
        }
        const nextString = nextPiecesForWorker.join('');
        
        const aiWorkerStartPayload = {
            type: 'start',
            boardString: boardString,
            nextString: nextString,
            isB2B: this.isB2B,
            ren: this.ren + 1,
        };
        
        if (this.aiWorker) {
            this.aiWorker.postMessage(aiWorkerStartPayload);
            this.aiWorker.postMessage({ type: 'stop' });
        }
    }


    getMinoShape_forAI(type, rotation) {
        rotation = rotation % 4;
        switch (type) {
            case 'I':
                if (rotation == 0) return [[0,0], [-1,0], [1,0], [2,0]];
                if (rotation == 1) return [[1,0], [1,-1], [1,1], [1,2]];
                if (rotation == 2) return [[0,1], [-1,1], [1,1], [2,1]];
                if (rotation == 3) return [[0,0], [0,-1], [0,1], [0,2]];
                break;
            case 'O':
                return [[0,0], [1,0], [0,-1], [1,-1]];
            case 'T':
                if (rotation == 0) return [[0,0], [-1,0], [1,0], [0,-1]];
                if (rotation == 1) return [[0,0], [0,-1], [1,0], [0,1]];
                if (rotation == 2) return [[0,0], [1,0], [-1,0], [0,1]];
                if (rotation == 3) return [[0,0], [0,1], [-1,0], [0,-1]];
                break;
            case 'S':
                if (rotation == 0) return [[0,0], [-1,0], [0,-1], [1,-1]];
                if (rotation == 1) return [[0,0], [0,-1], [1,0], [1,1]];
                if (rotation == 2) return [[0,0], [1,0], [0,1], [-1,1]];
                if (rotation == 3) return [[0,0], [0,1], [-1,0], [-1,-1]];
                break;
            case 'Z':
                if (rotation == 0) return [[0,0], [1,0], [0,-1], [-1,-1]];
                if (rotation == 1) return [[0,0], [0,1], [1,0], [1,-1]];
                if (rotation == 2) return [[0,0], [-1,0], [0,1], [1,1]];
                if (rotation == 3) return [[0,0], [0,-1], [-1,0], [-1,1]];
                break;
            case 'J':
                if (rotation == 0) return [[0,0], [-1,0], [1,0], [-1,-1]];
                if (rotation == 1) return [[0,0], [0,-1], [0,1], [1,-1]];
                if (rotation == 2) return [[0,0], [1,0], [-1,0], [1,1]];
                if (rotation == 3) return [[0,0], [0,1], [0,-1], [-1,1]];
                break;
            case 'L':
                if (rotation == 0) return [[0,0], [1,0], [-1,0], [1,-1]];
                if (rotation == 1) return [[0,0], [0,1], [0,-1], [1,1]];
                if (rotation == 2) return [[0,0], [-1,0], [1,0], [-1,1]];
                if (rotation == 3) return [[0,0], [0,-1], [0,1], [-1,-1]];
                break;
        }
        return [[0,0]];
    }

    srsOffsets_forAI = {
        common: {
            '0->1': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
            '1->0': [[0,0], [1,0], [1,-1], [0,2], [1,2]],
            '1->2': [[0,0], [1,0], [1,-1], [0,2], [1,2]],
            '2->1': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
            '2->3': [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
            '3->2': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
            '3->0': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
            '0->3': [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
        },
        I: {
            '0->1': [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
            '1->0': [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
            '1->2': [[0,0], [-1,0], [2,0], [-1,2], [2,-1]],
            '2->1': [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],
            '2->3': [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
            '3->2': [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
            '3->0': [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],
            '0->3': [[0,0], [-1,0], [2,0], [-1,2], [2,-1]],
        }
    };

    checkCollision_forAI(type, x, y, r, currentBoard) {
        const shape = this.getMinoShape_forAI(type, r);
        for (const [dx, dy] of shape) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx < 0 || nx >= BOARD_WIDTH || ny < 0 || ny >= BOARD_HEIGHT || (ny >= 0 && currentBoard[ny][nx])) {
                return true;
            }
        }
        return false;
    }

    tryRotate_forAI(type, x, y, r, direction, currentBoard) {
        const newR = (r + direction + 4) % 4;
        const offsetTable = (type === 'I' ? this.srsOffsets_forAI.I : this.srsOffsets_forAI.common);
        const offsetData = offsetTable[`${r}->${newR}`];

        for (const [ox, oy] of offsetData) {
            const newX = x + ox;
            const newY = y - oy;
            if (!this.checkCollision_forAI(type, newX, newY, newR, currentBoard)) {
                return { x: newX, y: newY, r: newR };
            }
        }
        return null;
    }

    checkTSpinCondition_forAI(target, minoType, currentBoard) {
        if (minoType !== 'T') {
            return false;
        }
        const { x, y } = target;
        const offsets = [[-1, -1], [1, -1], [-1, 1], [1, 1]];
        let filledCorners = 0;
        for (const [dx, dy] of offsets) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx < 0 || nx >= BOARD_WIDTH || ny < 0 || ny >= BOARD_HEIGHT || (ny >= 0 && currentBoard[ny][nx])) {
                filledCorners++;
            }
        }
        return filledCorners >= 3;
    }

    findShortestPath_forAI(start, target, minoType, currentBoard) {
        const queue = [[start.x, start.y, start.r, []]];
        const visited = new Set();
        visited.add(`${start.x},${start.y},${start.r}`);

        let shortestPath = null;
        let preferredPath = null;

        const isTSpinPriority = this.checkTSpinCondition_forAI(target, minoType, currentBoard);

        while (queue.length > 0) {
            const [x, y, r, path] = queue.shift();

            if (preferredPath && path.length >= preferredPath.length) {
                continue;
            }
            if (!isTSpinPriority && shortestPath && path.length >= shortestPath.length) {
                continue;
            }

            if (x === target.x && r === target.r) {
                let finalY = y;
                while (!this.checkCollision_forAI(minoType, x, finalY + 1, r, currentBoard)) {
                    finalY++;
                }
                if (finalY === target.y) {
                    const finalPath = [...path, '↑'];
                    if (!shortestPath) {
                        shortestPath = finalPath;
                    }

                    if (isTSpinPriority && !preferredPath) {
                        const isGrounded = this.checkCollision_forAI(minoType, x, y + 1, r, currentBoard);
                        if (path.length > 0) {
                            const lastMove = path[path.length - 1];
                            if ((lastMove === 'R' || lastMove === 'L') && isGrounded) {
                                const tempBoard = currentBoard.map(row => [...row]);
                                const shape = this.getMinoShape_forAI(minoType, r);
                                for (const [dx, dy] of shape) {
                                    const nx = x + dx;
                                    const ny = finalY + dy;
                                    if (ny >= 0 && ny < BOARD_HEIGHT && nx >= 0 && nx < BOARD_WIDTH) {
                                        tempBoard[ny][nx] = 1;
                                    }
                                }
                                let linesCleared = 0;
                                const checkedRows = new Set();
                                for (const [, dy] of shape) {
                                    const ny = finalY + dy;
                                    if (ny >= 0 && ny < BOARD_HEIGHT && !checkedRows.has(ny)) {
                                        checkedRows.add(ny);
                                        if (tempBoard[ny].every(cell => cell === 1)) {
                                            linesCleared++;
                                        }
                                    }
                                }
                                if (linesCleared > 0) {
                                    preferredPath = finalPath;
                                }
                            }
                        }
                    }
                    continue;
                }
            }


            const actions = ['R', 'L', '←', '→', '↓'];
            for (const action of actions) {
                let nextState = null;
                let newPath = [...path, action];

                switch (action) {
                    case '←':
                        nextState = { x: x - 1, y: y, r: r };
                        break;
                    case '→':
                        nextState = { x: x + 1, y: y, r: r };
                        break;
                    case '↓':
                        nextState = { x: x, y: y + 1, r: r };
                        break;
                    case 'R':
                        nextState = this.tryRotate_forAI(minoType, x, y, r, 1, currentBoard);
                        break;
                    case 'L':
                        nextState = this.tryRotate_forAI(minoType, x, y, r, -1, currentBoard);
                        break;
                }

                if (nextState) {
                    const stateKey = `${nextState.x},${nextState.y},${nextState.r}`;
                    if (!visited.has(stateKey) && !this.checkCollision_forAI(minoType, nextState.x, nextState.y, nextState.r, currentBoard)) {
                        visited.add(stateKey);
                        queue.push([nextState.x, nextState.y, nextState.r, newPath]);
                    }
                }
            }
        }

        const foundPath = preferredPath || shortestPath;
        if (foundPath) {
            return foundPath;
        }
        
        let alternativeTarget = null;
        if (minoType === 'I' || minoType === 'S' || minoType === 'Z') {
            const { x: tx, y: ty, r: tr } = target;
            if (minoType === 'I') {
                if (tr === 0) alternativeTarget = { x: tx, y: ty - 1, r: 2 };
                else if (tr === 2) alternativeTarget = { x: tx, y: ty + 1, r: 0 };
                else if (tr === 1) alternativeTarget = { x: tx + 1, y: ty, r: 3 };
                else if (tr === 3) alternativeTarget = { x: tx - 1, y: ty, r: 1 };
            } else if (minoType === 'S') {
                if (tr === 0) alternativeTarget = { x: tx, y: ty - 1, r: 2 };
                else if (tr === 2) alternativeTarget = { x: tx, y: ty + 1, r: 0 };

                else if (tr === 1) alternativeTarget = { x: tx + 1, y: ty, r: 3 };

                else if (tr === 3) alternativeTarget = { x: tx - 1, y: ty, r: 1 };

            } else if (minoType === 'Z') {
                if (tr === 0) alternativeTarget = { x: tx, y: ty - 1, r: 2 };

                else if (tr === 2) alternativeTarget = { x: tx, y: ty + 1, r: 0 };

                else if (tr === 1) alternativeTarget = { x: tx + 1, y: ty, r: 3 };

                else if (tr === 3) alternativeTarget = { x: tx - 1, y: ty, r: 1 };
 
            }
        }

        if (alternativeTarget) {
            const queue2 = [[start.x, start.y, start.r, []]];
            const visited2 = new Set([`${start.x},${start.y},${start.r}`]);
            while (queue2.length > 0) {
                 const [x, y, r, path] = queue2.shift();

                 if (x === alternativeTarget.x && r === alternativeTarget.r) {
                     let finalY = y;

                     while (!this.checkCollision_forAI(minoType, x, finalY + 1, r, currentBoard)) {
                         finalY++;

                     }
                     if (finalY === alternativeTarget.y) {
                         return [...path, '↑'];

                     }
                 }
                 const actions = ['R', 'L', '←', '→', '↓'];

                 for (const action of actions) {
                     let nextState = null;

                     let newPath = [...path, action];
                     switch (action) {
                         case '←': nextState = { x: x - 1, y: y, r: r };

                         break;
                         case '→': nextState = { x: x + 1, y: y, r: r }; break;

                         case '↓': nextState = { x: x, y: y + 1, r: r }; break;

                         case 'R': nextState = this.tryRotate_forAI(minoType, x, y, r, 1, currentBoard); break;

                         case 'L': nextState = this.tryRotate_forAI(minoType, x, y, r, -1, currentBoard); break;

                     }
                     if (nextState) {
                         const stateKey = `${nextState.x},${nextState.y},${nextState.r}`;

                         if (!visited2.has(stateKey) && !this.checkCollision_forAI(minoType, nextState.x, nextState.y, nextState.r, currentBoard)) {
                             visited2.add(stateKey);

                             queue2.push([nextState.x, nextState.y, nextState.r, newPath]);
                         }
                     }
                 }
            }
        }

        return null;

    }
async executeAiMove(move) {


        
        if (this.gameOver || !move) {
            this.isAiThinking = false;
            return;
        }

        if (this.player.pieceType !== move.piece) {
            if (this.canHold) {
                this.hold();
                await new Promise(resolve => setTimeout(resolve, gameSettings.aiMoveDelay));
            } else {
                this.isAiThinking = false;
                return;
            }
        }

        const startState = { x: this.player.x, y: this.player.y, r: this.player.rotation };
        const targetState = { x: move.x, y: move.y, r: move.rotation };
        const minoType = this.player.pieceType;
        if (minoType === 'I') {
            targetState.x += 1;
            startState.x += 1;
        }
        const pathfinderBoard = this.board.map(row => row.map(cell => (cell === null ? 0 : 1)));
        const path = this.findShortestPath_forAI(startState, targetState, minoType, pathfinderBoard);

        if (path) {
            for (const action of path) {
                switch (action) {
                    case '←': this.player.x--;
                        break;
                    case '→': this.player.x++; break;
                    case '↓': this.player.y++; break;
                    case 'R': {
                        const newState = this.tryRotate_forAI(minoType, this.player.x, this.player.y, this.player.rotation, 1, pathfinderBoard);
                        if (newState) {
                            this.player.x = newState.x;
                            this.player.y = newState.y;
                            this.player.rotation = newState.r;
                        }
                        break;
                    }
                    case 'L': {
                        const newState = this.tryRotate_forAI(minoType, this.player.x, this.player.y, this.player.rotation, -1, pathfinderBoard);
                        if (newState) {
                            this.player.x = newState.x;
                            this.player.y = newState.y;
                            this.player.rotation = newState.r;
                        }
                        break;
                    }
                    case '↑':
                        this.player.y = this.getGhostY();
                        break;
                }
                let delay = gameSettings.aiMoveDelay;
                if (action === '↓') {
                    delay = gameSettings.aiSdfDelay;
                }
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }

        if (path && path.length > 0) {
            const lastMeaningfulAction = path.at(-1) === '↑' && path.length > 1 ? path.at(-2) : path.at(-1);
            this.lastMoveWasRotation = lastMeaningfulAction === 'R' || lastMeaningfulAction === 'L';
        } else {
            this.lastMoveWasRotation = false;
}

        this.player.rotation = move.rotation;
        this.player.x = move.x;
        this.player.y = move.y;
        
        this.lockPiece();
this.isAiThinking = false;
    }

    async executeDrawMove(path) {
        if (this.isExecutingSequence) return;
        this.isExecutingSequence = true;

        for (const action of path) {
            if (this.gameOver || this.gameClear) break;
                        switch (action) {
                case '←': this.move(-1, 0); break;
                case '→': this.move(1, 0); break;
                case '↓': this.move(0, 1); break;
                case 'R': this.rotate(1); break;
                case 'L': this.rotate(-1); break;
                case '↑': this.hardDrop(); break;
            }
            await new Promise(resolve => setTimeout(resolve, gameSettings.drawMoveDelay));
        }

        this.isExecutingSequence = false;
}
    
    async processDrawing() {
        if (this.drawnBlocks.size !== 4) {
            this.drawnBlocks.clear();
return;
        }

        const blocks = Array.from(this.drawnBlocks.keys()).map(k => {
            const [x, y] = k.split(',').map(Number);
            return { x, y };
        });
blocks.sort((a, b) => a.y - b.y || a.x - b.x);

        const anchor = blocks[0];
const relativeCoords = blocks.slice(1).map(b => `${b.x - anchor.x},${b.y - anchor.y}`);
        const key = relativeCoords.sort().join(';');

        const shapeInfo = DRAW_SHAPE_MAP[key];
        this.drawnBlocks.clear();
if (!shapeInfo) return;

        const targetPieceType = shapeInfo.type;
        const targetState = {
            x: anchor.x - shapeInfo.offset[0],
            y: anchor.y - shapeInfo.offset[1],
            r: shapeInfo.rot
        };

        let path = null;
        let startState = null;
        let pieceForPathfinding = null;
        let holdIsNeeded = false;

        if (this.player.pieceType === targetPieceType) {
            pieceForPathfinding = this.player.pieceType;
            startState = { x: this.player.x, y: this.player.y, r: this.player.rotation };
            holdIsNeeded = false;
        } else if (this.canHold && (this.holdPiece === targetPieceType || (!this.holdPiece && this.nextQueue[0] === targetPieceType))) {
            pieceForPathfinding = targetPieceType;
            holdIsNeeded = true;
            
            const spawnX = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[pieceForPathfinding].center[0]) - 1;
            const tempShape = this.getShape(pieceForPathfinding, 0);
            let spawnY = 19;
            if (this.checkCollision(spawnX, spawnY, tempShape)) {
                spawnY = 18;
            }
            startState = { x: spawnX, y: spawnY, r: 0 };
        }
        
        if (startState) {
            if (pieceForPathfinding === 'I') {
                startState.x += 1;
                targetState.x += 1;
            }
            
            const pathfinderBoard = this.board.map(row => row.map(cell => (cell === null ? 0 : 1)));
            path = this.findShortestPath_forAI(startState, targetState, pieceForPathfinding, pathfinderBoard);
        }
        
        if (path) {
            if (holdIsNeeded) {
                this.hold();
                await new Promise(resolve => setTimeout(resolve, gameSettings.drawMoveDelay));
            }
            await this.executeDrawMove(path);
        }
    }
}
function setupEditors() { ['p1', 'p2'].forEach(setupPlayerEditor);

}


function setupPlayerEditor(playerId) {
    editorData[playerId].board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
    const nextIcons = document.getElementById(`${playerId}-next-icons`);
    Object.keys(TETROMINOS).forEach(key => {
        const icon = document.createElement('div');
icon.className = 'mino-icon';
        icon.style.backgroundColor = activeSkin[key];
        icon.addEventListener('click', () => {
            const data = editorData[playerId];
            if (data.nextInsertionIndex === 'hold') {
                data.hold = key;
                data.nextInsertionIndex = 0;
            } else if (data.nextInsertionIndex === -1) {
                data.nextQueue.push(key);
                data.nextInsertionIndex = data.nextQueue.length;
            } else {
                data.nextQueue.splice(data.nextInsertionIndex, 0, key);
                data.nextInsertionIndex++;
            }
            updateNextQueueDisplay(playerId);
        });
        nextIcons.appendChild(icon);
    });
    
    const endIcon = document.createElement('div');
    endIcon.className = 'mino-icon';
    endIcon.style.backgroundColor = activeSkin['E'];
    endIcon.style.color = '#FFFFFF';
    endIcon.style.display = 'flex';
    endIcon.style.alignItems = 'center';
    endIcon.style.justifyContent = 'center';
    endIcon.style.fontFamily = 'var(--font-display)';
    endIcon.style.fontSize = '14px';
    endIcon.style.fontWeight = 'bold';
endIcon.textContent = 'END';
    endIcon.addEventListener('click', () => {
        const data = editorData[playerId];
        if (data.nextInsertionIndex === 'hold' || data.nextQueue.length === 0) {
            return;
        }
        const key = 'E';
        if (data.nextInsertionIndex === -1) {
            data.nextQueue.push(key);
            data.nextInsertionIndex = data.nextQueue.length;
        } else {
            data.nextQueue.splice(data.nextInsertionIndex, 0, key);
            data.nextInsertionIndex++;
        }
        updateNextQueueDisplay(playerId);
    });
    nextIcons.appendChild(endIcon);
    
     document.getElementById(`${playerId}-next-delete-left`).addEventListener('click', () => {
        const data = editorData[playerId];
        const index = data.nextInsertionIndex;
        if (index === 'hold' || (index === -1 && data.nextQueue.length === 0)) {
            return;
        }
        if (index === 0) {
            data.hold = null;
        } else if (index > 0) {
            data.nextQueue.splice(index - 1, 1);
            data.nextInsertionIndex--;
        } else { // index is -1 (end of queue)
            data.nextQueue.pop();
            data.nextInsertionIndex = data.nextQueue.length;
        }
        updateNextQueueDisplay(playerId);
    });
    document.getElementById(`${playerId}-next-clear`).addEventListener('click', () => {
        editorData[playerId].nextQueue = [];
        editorData[playerId].hold = null;
        editorData[playerId].nextInsertionIndex = 0;
        updateNextQueueDisplay(playerId);
    });
    const palette = document.getElementById(`${playerId}-palette`);

    const autoSwatch = document.createElement('div');
    autoSwatch.className = 'color-swatch';
    autoSwatch.style.backgroundColor = '#FFFFFF';
    autoSwatch.style.color = '#000000';
    autoSwatch.style.display = 'flex';
    autoSwatch.style.alignItems = 'center';
    autoSwatch.style.justifyContent = 'center';
    autoSwatch.style.fontFamily = 'var(--font-display)';
    autoSwatch.style.fontSize = '12px';
    autoSwatch.style.fontWeight = 'bold';
    autoSwatch.textContent = 'Auto';
    autoSwatch.addEventListener('click', () => {
        editorData[playerId].activeColor = 'AUTO';
        palette.querySelector('.active')?.classList.remove('active');
        autoSwatch.classList.add('active');
    });
    palette.appendChild(autoSwatch);

    Object.keys(EDITOR_COLORS).filter(key => key !== 'E').forEach(key => { const swatch = document.createElement('div'); swatch.className = 'color-swatch'; swatch.style.backgroundColor = key === 'EMPTY' ? '#333' : EDITOR_COLORS[key]; if (key === 'EMPTY') { swatch.style.border = '1px dashed #fff'; swatch.title = 'Eraser'; } if (key === editorData[playerId].activeColor) swatch.classList.add('active'); swatch.addEventListener('click', () => { editorData[playerId].activeColor = key; palette.querySelector('.active')?.classList.remove('active'); swatch.classList.add('active'); }); palette.appendChild(swatch); });
const canvas = document.getElementById(`field-editor-canvas-${playerId}`);
    
    canvas.width = BOARD_WIDTH * EDITOR_BLOCK_SIZE; canvas.height = BOARD_VISIBLE_HEIGHT * EDITOR_BLOCK_SIZE;
    let isDrawing = false;
let isEraserMode = false;

    function checkForAndReplaceTetromino(playerId) {
        const board = editorData[playerId].board;
        const whiteBlocks = [];
        for (let r = 0; r < BOARD_HEIGHT; r++) {
            for (let c = 0; c < BOARD_WIDTH; c++) {
                if (board[r][c] === 'W') {
                    whiteBlocks.push({ y: r, x: c });
                }
            }
        }

        if (whiteBlocks.length !== 4) return;

        whiteBlocks.sort((a, b) => a.y !== b.y ? a.y - b.y : a.x - b.x);
        const anchor = whiteBlocks[0];

        const relativeCoords = whiteBlocks.slice(1).map(block => `${block.x - anchor.x},${block.y - anchor.y}`);
        const key = relativeCoords.sort().join(';');
        
        const createKey = (coords) => coords.map(c => `${c[0]},${c[1]}`).sort().join(';');

        const shapeMap = {
            [createKey([[1,0],[2,0],[3,0]])]: 'I', [createKey([[0,1],[0,2],[0,3]])]: 'I',
            [createKey([[0,1],[1,0],[1,1]])]: 'O',
            [createKey([[0,1],[1,1],[0,2]])]: 'T', [createKey([[0,1],[0,2],[-1,1]])]: 'T',
            [createKey([[-1,1],[0,1],[1,1]])]: 'T', [createKey([[1,0],[2,0],[1,1]])]: 'T',
            [createKey([[0,1],[1,2],[0,2]])]: 'L', [createKey([[1,0],[1,1],[1,2]])]: 'L',
            [createKey([[-1,1],[0,1],[-2,1]])]: 'L', [createKey([[1,0],[2,0],[0,1]])]: 'L',
            [createKey([[0,1],[-1,2],[0,2]])]: 'J', [createKey([[0,1],[0,2],[1,0]])]: 'J',
            [createKey([[2,1],[0,1],[1,1]])]: 'J', [createKey([[1,0],[2,0],[2,1]])]: 'J',
            [createKey([[0,1],[1,1],[1,2]])]: 'S', [createKey([[1,0],[0,1],[-1,1]])]: 'S',
            [createKey([[-1,1],[0,1],[-1,2]])]: 'Z', [createKey([[1,0],[2,1],[1,1]])]: 'Z',
        };

        const minoType = shapeMap[key];

        if (minoType) {
            whiteBlocks.forEach(block => {
                board[block.y][block.x] = minoType;
            });
        }
    }

    const getCoordsFromEvent = e => {
        const rect = canvas.getBoundingClientRect();
const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
const relativeX = (clientX - rect.left) / rect.width;
        const relativeY = (clientY - rect.top) / rect.height;
const x = Math.floor(relativeX * BOARD_WIDTH);
        const y = Math.floor(relativeY * BOARD_VISIBLE_HEIGHT);
        return { x, y };
    };
const applyDraw = (x, y) => {
        if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_VISIBLE_HEIGHT) return;

        const selectedColor = editorData[playerId].activeColor;
        const boardY = y + editorData[playerId].viewY;
        const board = editorData[playerId].board;

        if (selectedColor === 'AUTO') {
            const currentCell = board[boardY][x];
            if (isEraserMode) {
                if (currentCell === 'W') {
                    board[boardY][x] = null;
                }
            } else {
                if (currentCell === null) {
                    const whiteBlockCount = board.flat().filter(cell => cell === 'W').length;
                    if (whiteBlockCount < 4) {
                        board[boardY][x] = 'W';
                        if (whiteBlockCount + 1 === 4) {
                            checkForAndReplaceTetromino(playerId);
                        }
                    }
                }
            }
        } else {
            if (isEraserMode) {
                board[boardY][x] = null;
            } else {
                board[boardY][x] = (selectedColor === 'EMPTY') ? null : selectedColor;
            }
        }
        drawEditorField(playerId);
    };

    const handleDrawStart = e => {
        e.preventDefault();
isDrawing = true;
        const { x, y } = getCoordsFromEvent(e);
        const selectedColor = editorData[playerId].activeColor;

        if (selectedColor === 'AUTO') {
            if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_VISIBLE_HEIGHT) {
                const boardY = y + editorData[playerId].viewY;
                const currentCellColor = editorData[playerId].board[boardY][x];
                isEraserMode = (currentCellColor === 'W');
            }
        } else {
            if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_VISIBLE_HEIGHT) {
                const boardY = y + editorData[playerId].viewY;
                const currentCellColor = editorData[playerId].board[boardY][x];
                isEraserMode = (selectedColor === 'EMPTY' || currentCellColor === selectedColor);
            }
        }
        applyDraw(x, y);
    };
const handleDrawMove = e => {
        if (!isDrawing) return;
        e.preventDefault();
const { x, y } = getCoordsFromEvent(e);
        applyDraw(x, y);
    };
const handleDrawEnd = () => {
        if (!isDrawing) return;
        isDrawing = false;
isEraserMode = false;
    };

    canvas.addEventListener('mousedown', handleDrawStart);
    canvas.addEventListener('mouseup', handleDrawEnd);
    canvas.addEventListener('mouseleave', handleDrawEnd);
    canvas.addEventListener('mousemove', handleDrawMove);
    canvas.addEventListener('touchstart', handleDrawStart, { passive: false });
    canvas.addEventListener('touchend', handleDrawEnd, { passive: false });
    canvas.addEventListener('touchcancel', handleDrawEnd, { passive: false });
    canvas.addEventListener('touchmove', handleDrawMove, { passive: false });

    
    document.getElementById(`${playerId}-field-shift-up`).addEventListener('click', () => shiftField(playerId, 'up'));
    document.getElementById(`${playerId}-field-shift-down`).addEventListener('click', () => shiftField(playerId, 'down'));
    document.getElementById(`${playerId}-field-clear`).addEventListener('click', () => { editorData[playerId].board.forEach(row => row.fill(null)); drawEditorField(playerId); });
    drawEditorField(playerId);
}

function shiftField(playerId, direction) {
    const board = editorData[playerId].board;
    if (direction === 'up') {
        board.shift();
        board.push(Array(BOARD_WIDTH).fill(null));
    } else {
        board.pop();
        board.unshift(Array(BOARD_WIDTH).fill(null));
    }
    drawEditorField(playerId);
}

function updateNextQueueDisplay(playerId) {
    const qd = document.getElementById(`${playerId}-next-queue`);
    qd.innerHTML = '';
    const data = editorData[playerId];

    const createGap = (index) => {
        const gap = document.createElement('div');
        gap.style.width = '8px';
        gap.style.height = '38px';
        gap.style.cursor = 'pointer';
        gap.style.display = 'flex';
        gap.style.alignItems = 'center';
        gap.style.justifyContent = 'center';
        gap.style.userSelect = 'none';
        gap.addEventListener('click', (e) => {
            e.stopPropagation();
            data.nextInsertionIndex = index;
            updateNextQueueDisplay(playerId);
        });
        if (data.nextInsertionIndex === index) {
            gap.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
            gap.style.borderRadius = '2px';
            gap.innerHTML = '<span style="color: white; font-weight: bold; line-height: 1;">|</span>';
        }
        return gap;
    };

    const holdContainer = document.createElement('div');
    holdContainer.style.display = 'flex';
    holdContainer.style.alignItems = 'center';
    holdContainer.style.gap = '5px';
    holdContainer.style.padding = '0 8px';
    holdContainer.style.borderRight = '2px solid var(--primary-color)';

    const holdSlot = document.createElement('div');
    holdSlot.className = 'mino-icon';
    holdSlot.style.width = '38px';
    holdSlot.style.height = '38px';
    holdSlot.style.cursor = 'pointer';
    holdSlot.style.boxSizing = 'border-box';
    if (data.hold) {
        holdSlot.style.backgroundColor = activeSkin[data.hold];
    } else {
        holdSlot.style.backgroundColor = 'transparent';
        holdSlot.style.border = '2px dashed #555';
    }
    if (data.nextInsertionIndex === 'hold') {
        holdSlot.style.borderColor = '#FFF';
        holdSlot.style.boxShadow = '0 0 8px #FFF';
    }
    holdSlot.addEventListener('click', (e) => {
        e.stopPropagation();
        data.nextInsertionIndex = 'hold';
        updateNextQueueDisplay(playerId);
    });
    const holdLabel = document.createElement('span');
    holdLabel.textContent = "H";
    holdLabel.style.fontFamily = 'var(--font-display)';
    holdContainer.appendChild(holdLabel);
    holdContainer.appendChild(holdSlot);
    qd.appendChild(holdContainer);
    
    const nextContainer = document.createElement('div');
    nextContainer.style.display = 'flex';
    nextContainer.style.alignItems = 'center';
    nextContainer.style.gap = '5px';
    nextContainer.style.paddingLeft = '8px';
    nextContainer.style.flexWrap = 'wrap';

   nextContainer.appendChild(createGap(0));
    data.nextQueue.forEach((key, i) => {
        const icon = document.createElement('div');
        icon.className = 'mino-icon';
        icon.style.backgroundColor = activeSkin[key];
        icon.style.width = '38px';
        icon.style.height = '38px';
        if (key === 'E') {
            icon.textContent = 'END';
            icon.style.color = 'white';
            icon.style.display = 'flex';
            icon.style.alignItems = 'center';
            icon.style.justifyContent = 'center';
            icon.style.fontFamily = 'var(--font-display)';
            icon.style.fontSize = '12px';
            icon.style.fontWeight = 'bold';
        }
        nextContainer.appendChild(icon);
        nextContainer.appendChild(createGap(i + 1));
    });
    qd.appendChild(nextContainer);

    qd.onclick = (e) => {
        if (e.target === qd || e.target === nextContainer) {
            data.nextInsertionIndex = data.nextQueue.length;
            updateNextQueueDisplay(playerId);
        }
    };
}

function drawEditorField(playerId) {
    const canvas = document.getElementById(`field-editor-canvas-${playerId}`),
        ctx = canvas.getContext('2d'),
        data = editorData[playerId];
    ctx.fillStyle = '#0f0f18';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#444'; 
    ctx.lineWidth = 1;
    for (let y = 0; y < BOARD_VISIBLE_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
            const pieceType = data.board[y + data.viewY]?.[x];
            if (pieceType) {
                ctx.fillStyle = pieceType === 'W' ? '#FFFFFF' : activeSkin[pieceType];
ctx.fillRect(x * EDITOR_BLOCK_SIZE, y * EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE);
            }
            ctx.strokeRect(x * EDITOR_BLOCK_SIZE, y * EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE);
}
    }
}


function bindKey(binding) {
    if (!isBindingKey || !bindingPlayer || !bindingAction) return;
    
    keyBindings[bindingPlayer][bindingAction] = binding;
    isBindingKey = false;
    bindingAction = null;
    const tabToReopen = bindingPlayer === 'p1' ? 'p1-keys' : 'p2-keys';
    openUnifiedSettingsModal(tabToReopen);
}

function loadKeyBindings() {
    try {
        const savedBindings = JSON.parse(localStorage.getItem('tetrisKeyBindings'));
        if (savedBindings) {
            if (savedBindings.p1) Object.assign(keyBindings.p1, savedBindings.p1);
            if (savedBindings.p2) Object.assign(keyBindings.p2, savedBindings.p2);
        }
    } catch (e) { console.error("Failed to load key bindings from localStorage:", e); }
}

function saveGameSettings() {
    try {
        localStorage.setItem('tetrisGameSettings', JSON.stringify(gameSettings));
    } catch (e) { console.error("Failed to save game settings to localStorage:", e); }
}

function loadGameSettings() {
    try {
        const saved = localStorage.getItem('tetrisGameSettings');
        if (saved) {
            const parsed = JSON.parse(saved);
            Object.assign(gameSettings, parsed);
        }
    } catch(e) { console.error('Failed to load settings from localStorage:', e); }
}

function populateGeneralSettingsTab() {
    const list = document.getElementById('settings-list');
    list.innerHTML = '';
    const settingDetails = {
        das: { label: 'DAS (ms)', min: 0, max: 500, step: 10 },
        arr: { label: 'ARR (ms)', min: 0, max: 100, step: 1 },
        sdf: { label: 'SDF (ms)', min: 0, max: 100, step: 1 },
        lineClearDelay: { label: 'Line Clear Delay (ms)', min: 0, max: 2000, step: 50 },
        gravity: { label: 'Gravity Interval (ms)', min: 0, max: 9999999, step: 50 },
        lockDelay: { label: 'Lock Delay (ms)', min: 0, max: 9999999, step: 50 },
        maxNext: { label: 'Max NEXT Display', min: 1, max: 8, step: 1 },
        garbageGrace: { label: 'Garbage Grace (ms)', min: 0, max: 5000, step: 100 },
        garbageRandomness: { label: 'Garbage Hole Randomness (%)', min: 0, max: 100, step: 1 }
    };
    Object.keys(settingDetails).forEach(key => {
        const item = document.createElement('div'); item.className = 'setting-item';
        const label = document.createElement('span'); label.textContent = settingDetails[key].label;
        const input = document.createElement('input'); input.type = 'number';
        Object.assign(input, settingDetails[key]);
        let currentValue = gameSettings[key];
        if (key === 'garbageRandomness') currentValue *= 100;
        input.value = currentValue;
        input.onchange = e => {
            let val = parseFloat(e.target.value);
            if (key === 'garbageRandomness') gameSettings[key] = Math.max(0, Math.min(100, val)) / 100;
            else gameSettings[key] = Math.max(settingDetails[key].min, Math.min(settingDetails[key].max, val));
        };
        item.append(label, input); list.appendChild(item);
    });
    
    const checkboxSettings = { showEffects: 'エフェクトを表示する', showTimer: 'タイマーを表示する', touchControlsEnabled: 'タッチ操作を有効にする (P1)' };
Object.entries(checkboxSettings).forEach(([key, text], index) => {
        const item = document.createElement('div'); item.className = 'setting-item';
        if (index === 0) { item.style.cssText = 'margin-top:20px; border-top:1px solid var(--primary-color); padding-top:15px;'; }
        const label = document.createElement('label'); const checkbox = document.createElement('input');
        checkbox.type = 'checkbox'; checkbox.id = `setting-${key}`; checkbox.checked = !!gameSettings[key];
        checkbox.onchange = e => { gameSettings[key] = e.target.checked; };
        const span = document.createElement('span'); span.textContent = text;
 
       label.append(checkbox, span); item.appendChild(label); list.appendChild(item);
    });
}


function populateKeyConfigTab(playerId) {
    const list = document.getElementById(`${playerId}-key-config-list`);
    list.innerHTML = ''; 
    Object.keys(keyBindings[playerId]).forEach(action => {
        const item = document.createElement('div'); item.className = 'key-config-item';
        const label = document.createElement('span'); label.textContent = keyActionLabels[action];
        const btn = document.createElement('button'); btn.className = 'button';
        btn.textContent = keyBindings[playerId][action].label;
        btn.onclick = () => {
            isBindingKey = true; bindingPlayer = playerId; bindingAction = action;
            btn.textContent = 
'入力待機中...';
            list.querySelectorAll('button').forEach(b => { if (b !== btn) b.disabled = true; });
        };
        item.appendChild(label); item.appendChild(btn); list.appendChild(item);
    });
    if (playerId === 'p1') {
        const drawMoveDelayInput = document.getElementById('draw-move-delay-input');
        if (drawMoveDelayInput) {
            drawMoveDelayInput.value = gameSettings.drawMoveDelay;
            drawMoveDelayInput.onchange = e => {
                const val = parseInt(e.target.value, 10);
                if (!isNaN(val)) gameSettings.drawMoveDelay = Math.max(0, Math.min(200, val));
            };
        }
        const touchModeButtons = document.querySelectorAll('#p1-touch-mode-selection .button');
        touchModeButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.touchMode === gameSettings.touchControlType);
        });
        document.getElementById('p1-touch-button-controls').style.display = gameSettings.touchControlType === 'button' ? 'flex' : 'none';
        document.getElementById('p1-touch-draw-controls').style.display = gameSettings.touchControlType === 'draw' ? 'flex' : 'none';
    }
}



function populateAiSettingsTab() {

    const list = document.getElementById('ai-settings-list');
    list.innerHTML = '';

    const itemType = document.createElement('div');
    itemType.className = 'setting-item';
    const labelType = document.createElement('span');
    labelType.textContent = 'AIの種類';
    const selectType = document.createElement('select');
    selectType.style.minWidth = '150px';
    selectType.style.backgroundColor = 'var(--primary-color)';
    selectType.style.color = 'var(--font-color)';
    selectType.style.border = '1px solid var(--border-color)';
    selectType.style.padding = '5px';
    selectType.style.borderRadius = '4px';
    selectType.innerHTML = '<option value="default">Cold Clear (Strongly Simplified)</option>';
    itemType.append(labelType, selectType);
    list.appendChild(itemType);

    const settingDetails = {
        aiMoveDelay: { label: 'AIの操作入力間隔 (ms)', min: 20, max: 500, step: 1 },
        aiSdfDelay: { label: 'AI SDF (ms)', min: 0, max: 500, step: 1 }
    };
    
    Object.keys(settingDetails).forEach(key => {
        const item = document.createElement('div');
        item.className = 'setting-item';
        const label = document.createElement('span');
        label.textContent = settingDetails[key].label;
        const input = document.createElement('input');
        input.type = 'number';
        Object.assign(input, settingDetails[key]);
        input.value = gameSettings[key];
        input.onchange = e => {
            gameSettings[key] = Math.max(settingDetails[key].min, Math.min(settingDetails[key].max, parseInt(e.target.value, 10)));
        };
        item.append(label, input);
        list.appendChild(item);
    });
}

function openUnifiedSettingsModal(initialTab = 'general') {
    const modal = document.getElementById('settings-modal');
    
    const p2TabBtn = document.getElementById('p2-keys-tab-btn');
    if (gameMode === '2P') {
        p2TabBtn.style.display = 'block';
    } else {
        p2TabBtn.style.display = 'none';
        if (initialTab === 'p2-keys') initialTab = 'general';
    }

    populateGeneralSettingsTab();
    populateKeyConfigTab('p1');
    populateAiSettingsTab();
    if (gameMode === '2P') {
        populateKeyConfigTab('p2');
    }

    const tabs = modal.querySelectorAll('.tab-button');
    const contents = modal.querySelectorAll('.tab-content');
    
    function switchTab(tabName) {
        tabs.forEach(tab => tab.classList.toggle('active', tab.dataset.tab === tabName));
        contents.forEach(content => content.classList.toggle('active', content.id === `tab-content-${tabName}`));
    }
    
    tabs.forEach(tab => {
        tab.addEventListener('click', () => switchTab(tab.dataset.tab));
    });

    switchTab(initialTab);
    modal.style.display = 'flex';
}

function startScanProcess(file, playerId) { const reader = new FileReader(); reader.onload = e => { scanState.image = new Image(); scanState.image.onload = () => { scanState.targetPlayerId = playerId; scanState.bottomLeft = null; scanState.topRight = null; gameState = 'SCAN_BL'; document.getElementById('editor-container').style.display = 'none'; document.getElementById('game-container').style.display = 'block'; document.getElementById('scan-controls').style.display = 'flex'; 
const ar = scanState.image.naturalWidth / scanState.image.naturalHeight; const displayMaxWidth = window.innerWidth * 0.9; const displayMaxHeight = window.innerHeight * 0.8; let displayWidth = displayMaxWidth; let displayHeight = displayWidth / ar; if (displayHeight > displayMaxHeight) { displayHeight = displayMaxHeight; displayWidth = displayHeight * ar; } const canvasWidth = Math.min(2048, scanState.image.naturalWidth); mainCanvas.width = canvasWidth; mainCanvas.height = canvasWidth / ar; mainCanvas.style.width = `${displayWidth}px`; mainCanvas.style.height = `${displayHeight}px`; updateScanUI(); setTimeout(updateScale, 0);}; scanState.image.src = e.target.result; }; reader.readAsDataURL(file); }
function endScanProcess() { gameState = 'EDITING'; scanState.image = null; mainCanvas.style.width = ''; mainCanvas.style.height = ''; document.getElementById('editor-container').style.display = 'flex'; document.getElementById('game-container').style.display = 'none'; document.getElementById('scan-controls').style.display = 'none'; ['p1', 'p2'].forEach(drawEditorField); setTimeout(updateScale, 0); }
function updateScanUI() { const instructions = document.getElementById('scan-instructions'), confirmBtn = document.getElementById('scanConfirmBtn'); instructions.style.display = 'block'; mainCanvas.style.cursor = 'crosshair'; if (gameState === 'SCAN_BL') { instructions.textContent = '画像の盤面の「左下」をクリック'; confirmBtn.style.visibility = scanState.bottomLeft ? 'visible' : 'hidden'; } else if (gameState === 'SCAN_TR') { instructions.textContent = '「右上」をクリック →「読込開始」'; confirmBtn.style.visibility = scanState.topRight ? 'visible' : 'hidden'; if (scanState.topRight) confirmBtn.textContent = '読込開始'; else confirmBtn.textContent = '次へ'; } }
function drawScanner() { if (!scanState.image) return; ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height); ctx.drawImage(scanState.image, 0, 0, mainCanvas.width, mainCanvas.height); if (scanState.bottomLeft) { ctx.fillStyle = 'lime'; ctx.beginPath(); ctx.arc(scanState.bottomLeft.x, scanState.bottomLeft.y, 10, 0, Math.PI * 2); ctx.fill(); } if (scanState.topRight) { const {x: blx, y: bly} = scanState.bottomLeft, {x: trx, y: try_} = scanState.topRight; ctx.strokeStyle = 'fuchsia'; ctx.lineWidth = 4; ctx.strokeRect(blx, try_, trx - blx, bly - try_); } }
function processAndLoadBoard() { const tempC = document.createElement('canvas'); tempC.width = scanState.image.naturalWidth; tempC.height = scanState.image.naturalHeight; const tempCtx = tempC.getContext('2d', { willReadFrequently: true }); tempCtx.drawImage(scanState.image, 0, 0); const sX = scanState.image.naturalWidth / mainCanvas.width, sY = scanState.image.naturalHeight / mainCanvas.height; const iBL = { x: scanState.bottomLeft.x*sX, y: scanState.bottomLeft.y*sY }, iTR = { x: scanState.topRight.x*sX, y: scanState.topRight.y*sY }; const bW_px = iTR.x - iBL.x, bH_px = iBL.y - iTR.y, blW_px = bW_px/BOARD_WIDTH, blH_px = bH_px/BOARD_VISIBLE_HEIGHT; const targetBoard = editorData[scanState.targetPlayerId].board; targetBoard.forEach(row => row.fill(null)); for (let r = 0; r < BOARD_VISIBLE_HEIGHT; r++) { for (let c = 0; c < BOARD_WIDTH; c++) { const cX = iBL.x + (c+0.5)*blW_px, cY = iTR.y + (r+0.5)*blH_px; const sampleSize = Math.max(1, Math.floor(blW_px * 0.25)); const iD = tempCtx.getImageData(cX-sampleSize/2, cY-sampleSize/2, sampleSize, sampleSize).data; let avgR=0, avgG=0, avgB=0; for(let i=0; i<iD.length; i+=4){ avgR+=iD[i]; avgG+=iD[i+1]; avgB+=iD[i+2]; } const pCount = iD.length/4; avgR/=pCount; avgG/=pCount; avgB/=pCount; targetBoard[BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT + r][c] = findClosestColor(avgR, avgG, avgB); } } endScanProcess(); }

function findClosestColor(r, g, b) {
    const inputColor = { r, g, b };
    const colorDistanceSq = (c1, c2) => {
        return Math.pow(c1.r - c2.r, 2) + Math.pow(c1.g - c2.g, 2) + Math.pow(c1.b - c2.b, 2);
    };
    for (const nullColor of PARSED_SCAN_COLORS.NULL) {
        if (colorDistanceSq(inputColor, nullColor) < 6000) {
            return null;
        }
    }
    for (const gColor of PARSED_SCAN_COLORS.G) {
        if (colorDistanceSq(inputColor, gColor) < 10000) {
            return 'G';
        }
    }
    let minDistance = Infinity;
    let closestKey = null;
    const minoKeys = Object.keys(PARSED_SCAN_COLORS).filter(k => k !== 'NULL' && k !== 'G');
    for (const key of minoKeys) {
        for (const targetColor of PARSED_SCAN_COLORS[key]) {
            const distance = colorDistanceSq(inputColor, targetColor);
            if (distance < minDistance) {
                minDistance = distance;
                closestKey = key;
            }
        }
    }
    return (minDistance > 25000) ? null : closestKey;
}

function getAverageColorNonBlack(ctx, cx, cy, radius) {
    const startX = Math.floor(cx - radius);
    const startY = Math.floor(cy - radius);
    const diameter = Math.ceil(radius * 2);
    if (startX < 0 || startY < 0 || startX + diameter > ctx.canvas.width || startY + diameter > ctx.canvas.height) {
        return { r: 0, g: 0, b: 0 };
    }
    const imageData = ctx.getImageData(startX, startY, diameter, diameter).data;
    
    let totalR = 0, totalG = 0, totalB = 0, count = 0;
    const radiusSq = radius * radius;
    const blackThreshold = 50; 

    for (let y = 0; y < diameter; y++) {
        for (let x = 0; x < diameter; x++) {
            const dx = x - radius;
            const dy = y - radius;
            
            if (dx * dx + dy * dy <= radiusSq) {
                const i = (y * diameter + x) * 4;
                const r = imageData[i];
                const g = imageData[i + 1];
                const b = imageData[i + 2];
                
                if (r > blackThreshold || g > blackThreshold || b > blackThreshold) {
                    totalR += r;
                    totalG += g;
                    totalB += b;
                    count++;
                }
            }
        }
    }
    
    if (count === 0) {
        return { r: 0, g: 0, b: 0 };
    }
    
    return {
        r: totalR / count,
        g: totalG / count,
        b: totalB / count
    };
}

function findClosestMinoOnly(r, g, b) {
    const inputColor = { r, g, b };
    const colorDistanceSq = (c1, c2) => {
        return Math.pow(c1.r - c2.r, 2) + Math.pow(c1.g - c2.g, 2) + Math.pow(c1.b - c2.b, 2);
    };

    let minDistance = Infinity;
    let closestKey = 'I'; 
    
    const minoKeys = Object.keys(PARSED_SCAN_COLORS).filter(k => k !== 'NULL' && k !== 'G');
    
    for (const key of minoKeys) {
        for (const targetColor of PARSED_SCAN_COLORS[key]) {
            const distance = colorDistanceSq(inputColor, targetColor);
            if (distance < minDistance) {
                minDistance = distance;
                closestKey = key;
            }
        }
    }
    return closestKey;
}

function processPptImage(file) {
    const reader = new FileReader();
    reader.onload = e => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            let sx = 0, sy = 0, sWidth = img.naturalWidth, sHeight = img.naturalHeight;
            const originalAspectRatio = sWidth / sHeight;
            const targetAspectRatio = 16 / 9;

            if (originalAspectRatio > targetAspectRatio) {
                const newWidth = sHeight * targetAspectRatio;
                sx = (sWidth - newWidth) / 2;
                sWidth = newWidth;
            } else if (originalAspectRatio < targetAspectRatio) {
                const newHeight = sWidth / targetAspectRatio;
                sy = (sHeight - newHeight) / 2;
                sHeight = newHeight;
            }
            
            canvas.width = sWidth;
            canvas.height = sHeight;
            ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);

            loadBoardFromPptCanvas(canvas, 'p1');
            if (gameMode === '2P') {
                loadBoardFromPptCanvas(canvas, 'p2');
            }
            
            drawEditorField('p1');
            if (gameMode === '2P') {
                drawEditorField('p2');
            }
            updateNextQueueDisplay('p1');
            if (gameMode === '2P') {
                updateNextQueueDisplay('p2');
            }
            //alert('ぷよテト画像から盤面とネクストを読み込みました。');
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function loadBoardFromPptCanvas(sourceCanvas, playerId) {
    const ctx = sourceCanvas.getContext('2d', { willReadFrequently: true });
    const width = sourceCanvas.width;
    const scale = width / 1280;

    // --- Board Recognition ---
    const baseBoardCoords = {
        p1: { x1: 205, y1: 106, x2: 445, y2: 596 },
        p2: { x1: 835, y1: 106, x2: 1075, y2: 596 }
    };
    const boardCoords = baseBoardCoords[playerId];
    const boardTopLeft = { x: boardCoords.x1 * scale, y: boardCoords.y1 * scale };
    const boardWidthPx = (boardCoords.x2 - boardCoords.x1) * scale;
    const boardHeightPx = (boardCoords.y2 - boardCoords.y1) * scale;
    const blockWidthPx = boardWidthPx / BOARD_WIDTH;
    const blockHeightPx = boardHeightPx / BOARD_VISIBLE_HEIGHT;
    
    const targetBoard = editorData[playerId].board;
    targetBoard.forEach(row => row.fill(null));

    for (let r = 0; r < BOARD_VISIBLE_HEIGHT; r++) {
        for (let c = 0; c < BOARD_WIDTH; c++) {
            const sampleX = boardTopLeft.x + (c + 0.5) * blockWidthPx;
            const sampleY = boardTopLeft.y + (r + 0.5) * blockHeightPx;
            const sampleSize = Math.max(1, Math.floor(blockWidthPx * 0.25));
            const imageData = ctx.getImageData(sampleX - sampleSize / 2, sampleY - sampleSize / 2, sampleSize, sampleSize).data;
            
            let avgR = 0, avgG = 0, avgB = 0;
            for (let i = 0; i < imageData.length; i += 4) {
                avgR += imageData[i];
                avgG += imageData[i+1];
                avgB += imageData[i+2];
            }
            const pixelCount = imageData.length / 4;
            avgR /= pixelCount;
            avgG /= pixelCount;
            avgB /= pixelCount;
            
            targetBoard[BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT + r][c] = findClosestColor(avgR, avgG, avgB);
        }
    }

    // --- Post-processing: Clean up misidentified garbage ---
    let firstNonGarbageRowFromBottom = -1;
    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        if (!targetBoard[y].includes('G')) {
            firstNonGarbageRowFromBottom = y;
            break;
        }
    }
    if (firstNonGarbageRowFromBottom !== -1) {
        for (let y = firstNonGarbageRowFromBottom - 1; y >= 0; y--) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                if (targetBoard[y][x] === 'G') {
                    targetBoard[y][x] = null;
                }
            }
        }
    }

// --- Post-processing: Clean up floating blocks ---
    let firstEmptyRowFromBottom = -1;
    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        if (targetBoard[y].every(cell => cell === null)) {
            firstEmptyRowFromBottom = y;
            break;
        }
    }
    
    const deletedMinoColors = []; // 削除されたミノの色を記録する配列を追加

    if (firstEmptyRowFromBottom !== -1) {
        const seventeenthRowFromBottomIndex = BOARD_HEIGHT - 18;
        for (let y = firstEmptyRowFromBottom - 1; y >= 0; y--) {
            if (y <= seventeenthRowFromBottomIndex) {
                 // 行を単にnullで埋めるのではなく、各セルをチェックする
                 for (let x = 0; x < BOARD_WIDTH; x++) {
                    const piece = targetBoard[y][x];
                    if (piece && piece !== 'G') {
                        deletedMinoColors.push(piece); // おじゃま以外なら色を記録
                    }
                    targetBoard[y][x] = null; // セルを空にする
                 }
            }
        }
    }

    // --- Next Queue Recognition ---
    const nextCoordsP1 = [ { x: 160, y: 155 }, { x: 500, y: 122 }, { x: 500, y: 175 }, { x: 500, y: 225 }, { x: 500, y: 275 }, { x: 500, y: 325 } ];
    const nextCoordsP2 = [ { x: 790, y: 155 }, { x: 1130, y: 122 }, { x: 1130, y: 175 }, { x: 1130, y: 225 }, { x: 1130, y: 275 }, { x: 1130, y: 325 } ];
    const nextCoords = (playerId === 'p1') ? nextCoordsP1 : nextCoordsP2;
    const radius = 5 * scale;
    const newNextQueue = [];
    editorData[playerId].hold = null; // 最初にホールドをリセット

    for (let i = 0; i < nextCoords.length; i++) {
        const coord = nextCoords[i];
        const sampleX = coord.x * scale;
        const sampleY = coord.y * scale;
        
        const avgColor = getAverageColorNonBlack(ctx, sampleX, sampleY, radius);

        // 0番目の座標はホールド
        if (i === 0) {
            const foundHoldMino = findClosestMinoOnly(avgColor.r, avgColor.g, avgColor.b);
            editorData[playerId].hold = foundHoldMino;
        // 1番目以降の座標はネクスト
        } else {
            // 最初のネクストミノの場所が黒ければ、キューは空と判断して中断
            const isBlack = avgColor.r < 50 && avgColor.g < 50 && avgColor.b < 50;
            if (i === 1 && isBlack) {
                break;
            }
            
            const foundMino = findClosestMinoOnly(avgColor.r, avgColor.g, avgColor.b);
            if (foundMino) {
                newNextQueue.push(foundMino);
            }
        }
    }

    
    // 削除されたミノの色をチェックし、条件を満たせばNEXTキューに追加
    if (deletedMinoColors.length > 0 && deletedMinoColors.every(color => color === deletedMinoColors[0])) {
        const singleMinoType = deletedMinoColors[0];
        // ホールドは分離されたので、このミノはネクストキューの先頭に追加する
        newNextQueue.unshift(singleMinoType);
    }

    editorData[playerId].nextQueue = newNextQueue;
}

function boardToString(board) {
    return board.map(row => 
        row.map(cell => cell === null ? '_' : cell).join('')
    ).join('');
}

function stringToBoard(str) {
    const board = [];
    if (!str || str.length !== BOARD_WIDTH * BOARD_HEIGHT) {
        console.error('Invalid board string length. Returning empty board.');
        return Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
    }
    for (let i = 0; i < BOARD_HEIGHT; i++) {
        const rowStr = str.substring(i * BOARD_WIDTH, (i + 1) * BOARD_WIDTH);
        const row = rowStr.split('').map(char => (char === '_') ? null : char);
        board.push(row);
    }
    return board;
}

let autoStartParams = { ss: false, nh: false, hb: false };

function getGameStateForExport(options = {}) {
    const p1Data = { ...editorData.p1, nextQueue: [...editorData.p1.nextQueue] };
    const p2Data = gameMode === '2P' ? { ...editorData.p2, nextQueue: [...editorData.p2.nextQueue] } : null;
    if (options.noHold) {
        if (p1Data.hold) { p1Data.nextQueue.unshift(p1Data.hold); p1Data.hold = null; }
        if (p2Data && p2Data.hold) { p2Data.nextQueue.unshift(p2Data.hold); p2Data.hold = null; }
    }

    const data = {
        v: 2, m: gameMode,
        p1: { b: boardToString(p1Data.board), n: p1Data.nextQueue.join(''), h: p1Data.hold || '' }
    };
if (gameMode === '2P') {
        data.p2 = { b: boardToString(p2Data.board), n: p2Data.nextQueue.join(''), h: p2Data.hold || '' };
    }
    if (options.startSim) data.ss = 1;
    if (options.noHold) data.nh = 1;
    if (options.hideBack) data.hb = 1;
    
    if (editorData.rule.description) data.rd = editorData.rule.description;
    if (editorData.rule.code) data.rc = editorData.rule.code;

    return data;
}
function applyGameState(data) {
    try {
        if (!data || (data.v !== 1 && data.v !== 2)) {
            alert('無効または非対応のデータです。'); return false;
        }
        gameMode = data.m || '1P';
        document.getElementById('mode-1p').classList.toggle('active', gameMode === '1P');
        document.getElementById('mode-2p').classList.toggle('active', gameMode === '2P');
        document.getElementById('p2-editor-col').style.display = (gameMode === '2P') ? 'flex' : 'none';
        
        editorData.rule.description = data.rd || '';
        editorData.rule.code = data.rc || '';

        if (data.p1) {
            editorData.p1.board = stringToBoard(data.p1.b);
            editorData.p1.nextQueue = data.p1.n ? data.p1.n.split('') : [];
            editorData.p1.hold = data.p1.h || null;
            drawEditorField('p1'); updateNextQueueDisplay('p1');
        }
        if (gameMode === '2P' && data.p2) {
            editorData.p2.board = stringToBoard(data.p2.b);
            editorData.p2.nextQueue = data.p2.n ? data.p2.n.split('') : [];
            editorData.p2.hold = data.p2.h || null;
            drawEditorField('p2'); updateNextQueueDisplay('p2');
        } else if (gameMode !== '2P') {
            editorData.p2.board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
            editorData.p2.nextQueue = [];
            editorData.p2.hold = null;
            if (document.getElementById('p2-editor-col').style.display !== 'none') {
                 drawEditorField('p2'); updateNextQueueDisplay('p2');
            }
        }
        updateScale(); return true;
    } catch (e) {
        console.error('Failed to apply game state:', e); alert('データの読み込みに失敗しました。'); return false;
    }
}

function loadStateFromURL() {
    if (window.location.hash) {
        try {
            const base64Data = window.location.hash.substring(1);
            const binaryString = atob(base64Data);
            const bytes = Uint8Array.from(binaryString, c => c.charCodeAt(0));
            const jsonString = new TextDecoder().decode(bytes);
            const data = JSON.parse(jsonString);

            autoStartParams.ss = !!data.ss;
            autoStartParams.nh = !!data.nh;
            autoStartParams.hb = !!data.hb;

            if (applyGameState(data)) {
                //alert('URLから盤面を読み込みました。');
                if (autoStartParams.ss) {
                    setTimeout(() => document.getElementById('startGameBtn').click(), 100);
                }
            }
            history.pushState("", document.title, window.location.pathname + window.location.search);
        } catch (e) {
            console.error('Failed to load state from URL hash:', e);
            alert('URLからのデータ読み込みに失敗しました。');
            history.pushState("", document.title, window.location.pathname + window.location.search);
        }
    }
}


function generateAndDisplayLink(options = {}) {
    const stateData = getGameStateForExport(options);
    const jsonString = JSON.stringify(stateData);
    const uint8Array = new TextEncoder().encode(jsonString);
    const base64Data = btoa(String.fromCharCode.apply(null, uint8Array));
    const url = new URL(window.location);
    url.hash = base64Data;
    document.getElementById('share-link-input').value = url.href;
}

function openShareModal() {
    generateAndDisplayLink();
    document.getElementById('advanced-link-options').style.display = 'none';
    document.getElementById('share-modal').style.display = 'flex';
}
function pollGamepads() {
    const rawPads = navigator.getGamepads();
    if (!rawPads) return;

    for (let i = 0; i < rawPads.length; i++) {
        const pad = rawPads[i];
        if (!pad) {
            delete gamepads[i];
            delete prevGamepads[i];
            continue;
        };

        gamepads[i] = { buttons: pad.buttons.map(b => b.pressed), axes: [...pad.axes] };

        if (isBindingKey) {
            if (prevGamepads[i]) {
                for (let j = 0; j < pad.buttons.length; j++) {
                    if (gamepads[i].buttons[j] && !prevGamepads[i].buttons[j]) {
                        bindKey({ type: 'pad_button', value: j, label: `Pad${i}-Btn${j}` });
                        return;
                    }
                }
                for (let j = 0; j < pad.axes.length; j++) {
                    const val = gamepads[i].axes[j], prevVal = prevGamepads[i].axes[j];
                    if (Math.abs(val) > AXIS_THRESHOLD && Math.abs(prevVal) < AXIS_THRESHOLD) {
                        const dir = val > 0 ? '+' : '-';
                        bindKey({ type: 'pad_axis', value: `${j}${dir}`, label: `Pad${i}-Axis${j}${dir}` });
                        return;
                    }
                }
            }
        } else if (gameState === 'PLAYING') {
             players.forEach(p => {
                if(p.padIndex === i) {
                    Object.keys(p.keyBindings).forEach(action => {
                        const binding = p.keyBindings[action];
                        if (binding.type === 'pad_button' && gamepads[i].buttons[binding.value] && !prevGamepads[i]?.buttons[binding.value]) {
                           p.handlePress(action);
                        }
                    });
                }
            });
        }
    }
    Object.keys(gamepads).forEach(i => {
        prevGamepads[i] = { buttons: [...gamepads[i].buttons], axes: [...gamepads[i].axes] };
    });
}


function gameLoop(currentTime) {
    if (!ctx) return;
    pollGamepads();
    const dt = currentTime - lastTime;
    lastTime = currentTime;
    ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
    if (gameState === 'PLAYING') {
        players.forEach(p => p.update(dt || 0));
        players.forEach(p => p.draw());
    } else if (gameState.startsWith('SCAN')) {
        drawScanner();
    }
    requestAnimationFrame(gameLoop);
}

const mainContainer = document.querySelector('.main-container');

function updateScale() {
    if (gameState.startsWith('SCAN')) {
        mainContainer.style.transform = '';
        return;
    }

    mainContainer.style.transform = 'none';

    const rect = mainContainer.getBoundingClientRect();
    const nativeWidth = rect.width;
    const nativeHeight = rect.height;
    
    if (nativeWidth === 0 || nativeHeight === 0) {
        mainContainer.style.transform = '';
        return;
    }

    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    const scale = Math.min(
        viewportWidth / nativeWidth,
        viewportHeight / nativeHeight
    ) * 0.98;

    mainContainer.style.transform = `scale(${scale})`;
}

document.addEventListener('DOMContentLoaded', () => {
    mainCanvas = document.getElementById('mainCanvas'); ctx = mainCanvas.getContext('2d');
    
    aiWorkerBlob = new Blob([aiWorkerScript], { type: 'application/javascript' });
    
    virtualController.init();

    loadKeyBindings();
    loadGameSettings();

    document.getElementById('shareBtn').addEventListener('click', openShareModal);
    document.getElementById('share-close').addEventListener('click', () => {
        document.getElementById('share-modal').style.display = 'none';
    });

    document.getElementById('ruleBtn').addEventListener('click', () => {
        document.getElementById('rule-description-input').value = editorData.rule.description;
        document.getElementById('rule-code-input').value = editorData.rule.code;
        document.getElementById('rule-modal').style.display = 'flex';
    });
    document.getElementById('rule-save-close').addEventListener('click', () => {
        editorData.rule.description = document.getElementById('rule-description-input').value;
        editorData.rule.code = document.getElementById('rule-code-input').value;
        document.getElementById('rule-modal').style.display = 'none';
    });
    document.getElementById('rule-close').addEventListener('click', () => {
        document.getElementById('rule-modal').style.display = 'none';
    });
    
    document.getElementById('copy-link-btn').addEventListener('click', () => {
        const input = document.getElementById('share-link-input');
        input.select();
        navigator.clipboard.writeText(input.value)
            .then(() => alert('共有リンクをクリップボードにコピーしました！'))
            .catch(err => alert('コピーに失敗しました: ' + err));
    });
    


        document.getElementById('import-from-data-btn').addEventListener('click', async () => {
        try {
            const text = await navigator.clipboard.readText();
            if (!text) {
                alert('クリップボードが空です。');
                return;
            }

            let data;

                if (text.startsWith('http') && text.includes('#')) {
                const base64Data = text.substring(text.indexOf('#') + 1);
                const binaryString = atob(base64Data);
                const bytes = Uint8Array.from(binaryString, c => c.charCodeAt(0));
                const jsonString = new TextDecoder().decode(bytes);
                data = JSON.parse(jsonString);
            } else {
                data = JSON.parse(text);
            }
            
            if(applyGameState(data)) {
                 alert('クリップボードから盤面を読み込みました。');
                 document.getElementById('share-modal').style.display = 'none';
            }

        } catch (e) {
            alert('クリップボードのデータが無効か、読み込みに失敗しました。');
            console.error('Failed to import from clipboard:', e);
        }
    });


    document.getElementById('mode-1p').addEventListener('click', () => { 
        gameMode = '1P'; 
        document.getElementById('mode-1p').classList.add('active'); 
        document.getElementById('mode-2p').classList.remove('active'); 
        document.getElementById('p2-editor-col').style.display = 'none'; 
        setTimeout(updateScale, 0);
    });
    document.getElementById('mode-2p').addEventListener('click', () => { 
        gameMode = '2P'; 
        document.getElementById('mode-2p').classList.add('active'); 
        document.getElementById('mode-1p').classList.remove('active'); 
        document.getElementById('p2-editor-col').style.display = 'flex';
        setTimeout(updateScale, 0);
    });
    document.getElementById('advanced-link-btn').addEventListener('click', () => {
        document.getElementById('advanced-link-options').style.display = 'block';
    });
    
    const startSimCheckbox = document.getElementById('start-sim-checkbox');
    const hideBackCheckbox = document.getElementById('hide-back-btn-checkbox');
    startSimCheckbox.addEventListener('change', () => {
        if (startSimCheckbox.checked) {
            hideBackCheckbox.disabled = false;
        } else {
            hideBackCheckbox.disabled = true;
            hideBackCheckbox.checked = false;
        }
    });

    document.getElementById('generate-advanced-link-btn').addEventListener('click', () => {
        generateAndDisplayLink({
            startSim: document.getElementById('start-sim-checkbox').checked,
            noHold: document.getElementById('no-hold-checkbox').checked,
            hideBack: document.getElementById('hide-back-btn-checkbox').checked
        });
    });

document.getElementById('startGameBtn').addEventListener('click', () => {
        let currentRunSettings = { ...gameSettings };
        let userFunctions = {};
        let startTime = performance.now();
        
        players = [];
const p1_isAi = document.getElementById('p1-ai-toggle').checked;
        const p2_isAi = document.getElementById('p2-ai-toggle').checked;
        
        if (gameMode === '1P') {
            const player = new Player('1', 0, keyBindings.p1, 0, p1_isAi);
player.holdDisabled = autoStartParams.nh;
            players.push(player);
} else {
            const p1 = new Player('1', 0, keyBindings.p1, 0, p1_isAi);
            p1.holdDisabled = autoStartParams.nh;
            const p2 = new Player('2', PLAYER_CANVAS_WIDTH, keyBindings.p2, 1, p2_isAi);
            p2.holdDisabled = autoStartParams.nh;
            p1.opponent = p2;
p2.opponent = p1;
            players.push(p1, p2);
        }

        const createPlayerProxy = (player) => {
            if (!player) return null;
return {
                get stats() { return player.stats;
},
                board: {
                    hasBlock: (x, y) => {
                        if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT) return true;
return player.board[y][x] !== null;
                    },
                    placeBlock: (x, y, type) => {
                        if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                           player.board[y][x] = Object.keys(COLORS).includes(type) ?
type : null;
                        }
                    },
                },
            };
};

        const p1Proxy = createPlayerProxy(players[0]);
        const p2Proxy = createPlayerProxy(players[1]);

        const gameApi = {
            win: (player) => {
                let targetPlayer = null;
                if (player instanceof Player) {
                    targetPlayer = player;
                } else if (player === p1Proxy) {
                    targetPlayer = players[0];
                } else if (player === p2Proxy) {
                    targetPlayer = players[1];
                }

                if (targetPlayer) {
                    targetPlayer.gameClear = true;
                    const message = 'clear';
                    const targetOrigin = '*';
                    window.parent.postMessage(message, targetOrigin);
                }
            },
            lose: (player) => {
                let targetPlayer = null;
                if (player instanceof Player) {
                    targetPlayer = player;
                } else if (player === p1Proxy) {
                    targetPlayer = players[0];
                } else if (player === p2Proxy) {
                    targetPlayer = players[1];
                }

                if (targetPlayer) {
                    targetPlayer.gameOver = true;
                }
            },
            displayGhostBlock: (player, x, y, type) => {
                const targetPlayer = (player === p1Proxy && players[0]) ?
                    players[0] :
                    (player === p2Proxy && players[1]) ?
                    players[1] : null;
                if (targetPlayer) {
                    if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                        const pieceType = Object.keys(COLORS).includes(type) ? type : null;
                        targetPlayer.customGhosts.push({x, y, pieceType});
                    }
                }
            },
            clearAllGhostBlocks: (player) => {
                const targetPlayer = (player === p1Proxy && players[0]) ?
                    players[0] :
                    (player === p2Proxy && players[1]) ?
                    players[1] : null;
                if (targetPlayer) {
                    targetPlayer.customGhosts = [];
                }
            },
            setCustomUIText: (player, text) => {
                const targetPlayer = (player === p1Proxy && players[0]) ?
players[0] :
                    (player === p2Proxy && players[1]) ?
players[1] : null;
                if (targetPlayer) {

                    targetPlayer.customUIText = String(text);
                }
            },
            getTime: () => performance.now() - startTime,
            sendAttack: (receivingPlayer, lines) => {
                const targetPlayer = (receivingPlayer === p1Proxy && players[0]) ?
                    players[0] :
                    (receivingPlayer === p2Proxy && players[1]) ?
                    players[1] : null;
                if (targetPlayer) {
                    targetPlayer.garbageQueue.push({
                        lines: lines,
                        receivedTime: performance.now()
                    });
                }
            },
            forceSetting: (key, value) => {
                if (key in currentRunSettings) {
                    currentRunSettings[key] = value;
                } else {
                    console.warn(`Rule tried to force unknown setting: ${key}`);
                }
            },
            p1: p1Proxy,
            p2: p2Proxy
        };

        
        if (editorData.rule.code) {
            try {
                const combinedCode = editorData.rule.code + 
                    `\nreturn { 
                        onInit: typeof onInit === 'function' ? onInit : undefined,
     onPieceLock: typeof onPieceLock === 'function' ? onPieceLock : undefined,
                        onUpdate: typeof onUpdate === 'function' ?
onUpdate : undefined
                    };`;
const ruleScript = new Function('api', combinedCode);
                const returnedFuncs = ruleScript(gameApi);
if (returnedFuncs.onInit) {
                    returnedFuncs.onInit(gameApi);
}
                userFunctions = returnedFuncs;
} catch (e) {
                alert('カスタムルールコードの実行中にエラーが発生しました:\n' + e.message);
console.error("Custom rule script error:", e);
                return;
            }
        }
        
        players.forEach(p => {
            p.ruleHooks = userFunctions;
            p.gameApi = gameApi;
        });

        const originalSettingsBeforeRun = { ...gameSettings };
Object.assign(gameSettings, currentRunSettings);

        gameState = 'PLAYING'; 
        document.getElementById('editor-container').style.display = 'none'; 
        document.getElementById('game-container').style.display = 'block';
        document.getElementById('scan-controls').style.display = 'none';
        document.getElementById('game-controls').style.display = 'flex';
const ruleDescDisplay = document.getElementById('rule-description-display');
        if (editorData.rule.description) {
            ruleDescDisplay.innerText = editorData.rule.description;
ruleDescDisplay.style.display = 'block';
            const p1OffsetX = 0;
            const leftPos = p1OffsetX + PADDING;
            const topPos = 160; 
            ruleDescDisplay.style.left = `${leftPos}px`;
ruleDescDisplay.style.top = `${topPos}px`;
            ruleDescDisplay.style.maxWidth = `${HOLD_AREA_WIDTH - PADDING}px`;
        } else {
            ruleDescDisplay.style.display = 'none';
}
        
        if (autoStartParams.hb) {
            document.getElementById('backToEditorBtn').style.display = 'none';
} else {
            document.getElementById('backToEditorBtn').style.display = '';
}

        ctx.setTransform(1, 0, 0, 1, 0, 0);

        if (gameMode === '1P') {
            mainCanvas.width = PLAYER_CANVAS_WIDTH * RESOLUTION_SCALE;
mainCanvas.height = CANVAS_HEIGHT * RESOLUTION_SCALE;
            mainCanvas.style.width = PLAYER_CANVAS_WIDTH + 'px';
            mainCanvas.style.height = CANVAS_HEIGHT + 'px';
}
        else {
            const totalWidth = PLAYER_CANVAS_WIDTH * 2;
mainCanvas.width = totalWidth * RESOLUTION_SCALE; 
            mainCanvas.height = CANVAS_HEIGHT * RESOLUTION_SCALE;
            mainCanvas.style.width = totalWidth + 'px';
            mainCanvas.style.height = CANVAS_HEIGHT + 'px';
        }

        
        autoStartParams = { ss: false, nh: false, hb: false };
        ctx.scale(RESOLUTION_SCALE, RESOLUTION_SCALE);

if (gameSettings.touchControlsEnabled && gameSettings.touchControlType === 'button') {
            virtualController.show();
        }

        const aiDebugDisplay = document.getElementById('ai-debug-display');
        const aiDebugControls = document.getElementById('ai-debug-controls');
        if (players.some(p => p.isAi)) {
            if(aiDebugDisplay) aiDebugDisplay.style.display = 'none';
            if(aiDebugControls) aiDebugControls.style.display = 'none';
        } else {
            if(aiDebugDisplay) aiDebugDisplay.style.display = 'none';
            if(aiDebugControls) aiDebugControls.style.display = 'none';
        }

        setTimeout(updateScale, 0);
    });


document.getElementById('backToEditorBtn').addEventListener('click', () => {
        gameState = 'EDITING';
        
        if (players.length > 0) {
            players.forEach(p => {
                if (p.aiWorker) {
                    p.aiWorker.terminate();
                }
            });
        }
        
        players = [];
        loadGameSettings();
        document.getElementById('game-container').style.display = 'none';
        document.getElementById('game-controls').style.display = 'none';
        document.getElementById('editor-container').style.display = 'flex';
        document.getElementById('rule-description-display').style.display = 'none';
        
        virtualController.hide();
        
        const aiDebugDisplay = document.getElementById('ai-debug-display');
        const aiDebugControls = document.getElementById('ai-debug-controls');
        if(aiDebugDisplay) aiDebugDisplay.style.display = 'none';
        if(aiDebugControls) aiDebugControls.style.display = 'none';

        setTimeout(updateScale, 0);
    });
    
    ['p1', 'p2'].forEach(pId => { 
        document.getElementById(`imageLoader-${pId}`).addEventListener('change', e => { 
            if (e.target.files && e.target.files[0]) {
                startScanProcess(e.target.files[0], e.target.dataset.player);
            }
        }); 
        document.getElementById(`pptLoader-${pId}`).addEventListener('change', e => { 
            if (e.target.files && e.target.files[0]) {
                processPptImage(e.target.files[0]);
            }
        });
    });
    document.getElementById('scanCancelBtn').addEventListener('click', endScanProcess);
    document.getElementById('scanConfirmBtn').addEventListener('click', () => { if (gameState === 'SCAN_BL' && scanState.bottomLeft) gameState = 'SCAN_TR'; else if (gameState === 'SCAN_TR' && scanState.topRight) processAndLoadBoard(); updateScanUI(); });
    mainCanvas.addEventListener('click', e => { if (!gameState.startsWith('SCAN')) return; const rect = mainCanvas.getBoundingClientRect();
    const scaleX = mainCanvas.width / rect.width;
    const scaleY = mainCanvas.height / rect.height;
    const pos = { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
    if (gameState==='SCAN_BL') scanState.bottomLeft=pos; else if (gameState==='SCAN_TR') scanState.topRight=pos; updateScanUI(); });

    const getDrawCoordsFromEvent = (e) => {
        if (!players[0]) return null;
        const rect = mainCanvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const x = Math.floor(((clientX - rect.left) / rect.width) * (mainCanvas.width / RESOLUTION_SCALE) / BLOCK_SIZE - (PLAYFIELD_X_OFFSET / BLOCK_SIZE));
        const y = Math.floor(((clientY - rect.top) / rect.height) * (mainCanvas.height / RESOLUTION_SCALE) / BLOCK_SIZE - 0.5) + players[0].viewY;
        return { x, y };
    };

    const handleDrawStartOnBoard = e => {
        if (gameState !== 'PLAYING' || !gameSettings.touchControlsEnabled || gameSettings.touchControlType !== 'draw' || !players[0] || players[0].isExecutingSequence) return;
e.preventDefault();
        players[0].isDrawingOnBoard = true;
        const coords = getDrawCoordsFromEvent(e);

        if (coords && coords.x >= 0 && coords.x < BOARD_WIDTH && coords.y >= 0 && coords.y < BOARD_HEIGHT && !players[0].board[coords.y][coords.x]) {
            players[0].drawnBlocks.set(`${coords.x},${coords.y}`, true);
        }
    };

    const handleDrawMoveOnBoard = e => {
        if (gameState !== 'PLAYING' || !gameSettings.touchControlsEnabled || gameSettings.touchControlType !== 'draw' || !players[0] || !players[0].isDrawingOnBoard) return;
        e.preventDefault();
        const coords = getDrawCoordsFromEvent(e);
        if (coords && coords.x >= 0 && coords.x < BOARD_WIDTH && coords.y >= 0 && coords.y < BOARD_HEIGHT && !players[0].board[coords.y][coords.x]) {
            if (players[0].drawnBlocks.size < 4) {
                 players[0].drawnBlocks.set(`${coords.x},${coords.y}`, true);
            }
        }
    };

    const handleDrawEndOnBoard = e => {
        if (gameState !== 'PLAYING' || !gameSettings.touchControlsEnabled || gameSettings.touchControlType !== 'draw' || !players[0] || !players[0].isDrawingOnBoard) return;
        e.preventDefault();
        players[0].isDrawingOnBoard = false;
        players[0].processDrawing();
    };

    mainCanvas.addEventListener('mousedown', handleDrawStartOnBoard);
    mainCanvas.addEventListener('mousemove', handleDrawMoveOnBoard);
    mainCanvas.addEventListener('mouseup', handleDrawEndOnBoard);
    mainCanvas.addEventListener('mouseleave', handleDrawEndOnBoard);
    mainCanvas.addEventListener('touchstart', handleDrawStartOnBoard, { passive: false });
    mainCanvas.addEventListener('touchmove', handleDrawMoveOnBoard, { passive: false });
    mainCanvas.addEventListener('touchend', handleDrawEndOnBoard, { passive: false });
    mainCanvas.addEventListener('touchcancel', handleDrawEndOnBoard, { passive: false });

    document.getElementById('settingsBtn').addEventListener('click', () => openUnifiedSettingsModal('general'));
    document.getElementById('p1-key-config-btn').addEventListener('click', () => openUnifiedSettingsModal('p1-keys'));
    document.getElementById('p2-key-config-btn').addEventListener('click', () => openUnifiedSettingsModal('p2-keys'));

    document.getElementById('settings-close').addEventListener('click', () => {
        saveGameSettings();
        try { localStorage.setItem('tetrisKeyBindings', JSON.stringify(keyBindings)); } 
        catch (e) { console.error("Failed to save key bindings to localStorage:", e); }

        document.getElementById('settings-modal').style.display = 'none';
        isBindingKey = false; bindingPlayer = null; bindingAction = null;
    });

    document.getElementById('vc-edit-layout-btn').addEventListener('click', () => {
        document.getElementById('settings-modal').style.display = 'none';
        virtualController.startEditMode();
    });

    const touchModeButtons = document.querySelectorAll('#p1-touch-mode-selection .button');
        touchModeButtons.forEach(button => {
        button.addEventListener('click', () => {
            const newMode = button.dataset.touchMode;
            gameSettings.touchControlType = newMode;
            touchModeButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            document.getElementById('p1-touch-button-controls').style.display = newMode === 'button' ? 'flex' : 'none';
            document.getElementById('p1-touch-draw-controls').style.display = newMode === 'draw' ? 'flex' : 'none';
       
 });
    });

    document.getElementById('vc-save-and-close-btn').addEventListener('click', () => {

        virtualController.endEditMode();
    });
    document.getElementById('vc-copy-layout-btn').addEventListener('click', virtualController.copyLayoutsToClipboard);
    document.getElementById('vc-paste-layout-btn').addEventListener('click', virtualController.importLayoutsFromClipboard);

    document.addEventListener('keydown', e => {
        if (isBindingKey) {
            e.preventDefault();
            let keyLabel = e.key;
            if (keyLabel === ' ') keyLabel = 'Space';
            bindKey({ type: 'key', value: e.key.toLowerCase(), label: keyLabel });
        } 
        else if (gameState === 'PLAYING') {
            players.forEach(p => {
                p.keys[e.key.toLowerCase()] = true;
                Object.keys(p.keyBindings).forEach(action => {
                    const binding = p.keyBindings[action];
                    if (binding.type === 'key' && binding.value === e.key.toLowerCase()) {
                        p.handlePress(action);
                    }
                });
            });
        }
    });
    document.addEventListener('keyup', e => {
        if (gameState === 'PLAYING') {
            players.forEach(p => p.keys[e.key.toLowerCase()] = false );
        }
    });

    const manifest = {
        "name": "Tetris Simulator", "short_name": "TetrisSim", "start_url": ".",
        "display": "standalone", "background_color": "#1a1a2e", "theme_color": "#1a1a2e",
        "description": "A Tetris simulator with a 2-player mode and a powerful board editor.",
    "icons": [
        { "src": "https://raw.githubusercontent.com/selmtoe/Tetris_Simulator/main/icons/icon-192x192.png", "type": "image/png", "sizes": "192x192" },
        { "src": "https://raw.githubusercontent.com/selmtoe/Tetris_Simulator/main/icons/icon-512x512.png", "type": "image/png", "sizes": "512x512" }
    ]
    };
    const manifestURL = 'data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(manifest))));
    document.getElementById('manifest-link').setAttribute('href', manifestURL);
    if ('serviceWorker' in navigator) {
        const swCode = `
            const CACHE_NAME = 'tetris-sim-cache-v1';
            self.addEventListener('install', event => {
                event.waitUntil(
                    caches.open(CACHE_NAME).then(cache => {
                        return cache.add(location.pathname);
                    })
                );
            });
            self.addEventListener('fetch', event => {
                event.respondWith(
                    caches.match(event.request).then(response => {
                        return response || fetch(event.request);
                    })
                );
            });
        `;
        const blob = new Blob([swCode], { type: 'application/javascript' });
        navigator.serviceWorker.register(URL.createObjectURL(blob))
            .then(reg => console.log('Service Worker registered successfully.'))
            .catch(err => console.error('Service Worker registration failed:', err));
    }
    
document.getElementById('retryBtn').addEventListener('click', () => {
        if (gameState !== 'PLAYING' || !players.length) return;
        
        players.forEach(p => {
            if (p.aiWorker) {
                p.aiWorker.terminate();
            }
        });

        loadGameSettings();
        
        let currentRunSettings = { ...gameSettings };
        let userFunctions = {};
        let startTime = performance.now();
        const wasHoldDisabled = players[0].holdDisabled;

        const p1_isAi_retry = document.getElementById('p1-ai-toggle').checked;
        const p2_isAi_retry = document.getElementById('p2-ai-toggle').checked;

        const tempPlayers = [];
        if (gameMode === '1P') {
            const p = new Player('1', 0, keyBindings.p1, 0, p1_isAi_retry);
            p.holdDisabled = wasHoldDisabled;
            tempPlayers.push(p);
        } else {
            const p1 = new Player('1', 0, keyBindings.p1, 0, p1_isAi_retry);
            p1.holdDisabled = wasHoldDisabled;
            const p2 = new Player('2', PLAYER_CANVAS_WIDTH, keyBindings.p2, 1, p2_isAi_retry);
            p2.holdDisabled = wasHoldDisabled;
            p1.opponent = p2;
            p2.opponent = p1;
            tempPlayers.push(p1, p2);
        }

        const createPlayerProxy = (player) => {
            if (!player) return null;
            return {
                get stats() { return player.stats; },
                board: {
                    hasBlock: (x, y) => {
                        if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT) return true;
                        return player.board[y][x] !== null;
                    },
                    placeBlock: (x, y, type) => {
                        if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                           player.board[y][x] = Object.keys(COLORS).includes(type) ? type : null;
                        }
                    },
                },
            };
        };

        const p1Proxy = createPlayerProxy(tempPlayers[0]);
        const p2Proxy = createPlayerProxy(tempPlayers[1]);
        
        const gameApi = {
            win: (player) => {
                let targetPlayer = null;
                if (player instanceof Player) {
                    targetPlayer = player;
                } else if (player === p1Proxy) {
                    targetPlayer = tempPlayers[0];
                } else if (player === p2Proxy) {
                    targetPlayer = tempPlayers[1];
                }

                if (targetPlayer) {
                    targetPlayer.gameClear = true;
                    const message = 'clear';
                    const targetOrigin = '*';
                    window.parent.postMessage(message, targetOrigin);
                }
            },
            lose: (player) => {
                let targetPlayer = null;
                if (player instanceof Player) {
                    targetPlayer = player;
                } else if (player === p1Proxy) {
                    targetPlayer = tempPlayers[0];
                } else if (player === p2Proxy) {
                    targetPlayer = tempPlayers[1];
                }

                if (targetPlayer) {
                    targetPlayer.gameOver = true;
                }
            },
            displayGhostBlock: (player, x, y, type) => {
                const targetPlayer = (player === p1Proxy && tempPlayers[0]) ?
                    tempPlayers[0] :
                    (player === p2Proxy && tempPlayers[1]) ?
                    tempPlayers[1] : null;
                if (targetPlayer) {
                    if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                        const pieceType = Object.keys(COLORS).includes(type) ? type : null;
                        targetPlayer.customGhosts.push({x, y, pieceType});
                    }
                }
            },
            clearAllGhostBlocks: (player) => {
                const targetPlayer = (player === p1Proxy && tempPlayers[0]) ?
                    tempPlayers[0] :
                    (player === p2Proxy && tempPlayers[1]) ?
                    tempPlayers[1] : null;
                if (targetPlayer) {
                    targetPlayer.customGhosts = [];
                }
            },
            setCustomUIText: (player, text) => {
                const targetPlayer = (player === p1Proxy && tempPlayers[0]) ?
tempPlayers[0] :
                    (player === p2Proxy && tempPlayers[1]) ?
tempPlayers[1] : null;
                if (targetPlayer) {

                    targetPlayer.customUIText = String(text);
                }
            },
            getTime: () => performance.now() - startTime,
            sendAttack: (receivingPlayer, lines) => {
                const targetPlayer = (receivingPlayer === p1Proxy && tempPlayers[0]) ?
                    tempPlayers[0] :
                    (receivingPlayer === p2Proxy && tempPlayers[1]) ?
                    tempPlayers[1] : null;
                if (targetPlayer) {
                    targetPlayer.garbageQueue.push({
                        lines: lines,
                        receivedTime: performance.now()
                    });
                }
            },
            forceSetting: (key, value) => {
                if (key in currentRunSettings) {
                    currentRunSettings[key] = value;
                } else {
                    console.warn(`Rule tried to force unknown setting: ${key}`);
                }
            },
            p1: p1Proxy,
            p2: p2Proxy
        };

     
   if (editorData.rule.code) {
            try {
                const combinedCode = editorData.rule.code + 
                    `\nreturn { 
                      onInit: typeof onInit === 'function' ? onInit : undefined,
                        onPieceLock: typeof onPieceLock === 'function' ?
onPieceLock : undefined,
                        onUpdate: typeof onUpdate === 'function' ?
onUpdate : undefined
                    };`;
const ruleScript = new Function('api', combinedCode);
                const returnedFuncs = ruleScript(gameApi);
if (returnedFuncs.onInit) {
                    returnedFuncs.onInit(gameApi);
}
                userFunctions = returnedFuncs;
} catch (e) {
                alert('リトライ時にカスタムルールコードの実行でエラーが発生しました:\n' + e.message);
console.error("Custom rule script error on retry:", e);
                return;
            }
        }
        
        Object.assign(gameSettings, currentRunSettings);
        players = tempPlayers;
        players.forEach(p => {
            p.ruleHooks = userFunctions;
            p.gameApi = gameApi;
        });
});
    document.getElementById('gameSettingsBtn').addEventListener('click', () => {
        openUnifiedSettingsModal('general');
    });
    setupEditors();

    loadStateFromURL();

    lastTime = performance.now(); 
    requestAnimationFrame(gameLoop);

    
    window.addEventListener('resize', updateScale);

    setTimeout(updateScale, 100);

    document.getElementById('ai-debug-execute').addEventListener('click', () => {
        const piece = document.getElementById('ai-debug-piece').value.toUpperCase();
        const x = parseInt(document.getElementById('ai-debug-x').value, 10);
        const y = parseInt(document.getElementById('ai-debug-y').value, 10);
        const rot = parseInt(document.getElementById('ai-debug-rot').value, 10);

        if (!piece || isNaN(x) || isNaN(y) || isNaN(rot)) {
            alert('Invalid debug input.');
            return;
        }

        const aiPlayer = players.find(p => p.isAi);
        if (!aiPlayer) {
            alert('No AI player found to execute the move.');
            return;
        }
        
        const move = {
            pieceType: piece,
            x: x,
            y: y,
            rotation: rot
        };

        aiPlayer.executeAiMove(move);
    });
});
</script>
</body>
</html>
